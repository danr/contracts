\documentclass[preprint,nocopyrightspace]{sigplanconf}

\usepackage{hcc-techreport}

\begin{document} 
\preprintfooter{\textbf{--- DRAFT ---}}


\newcommand{\Ct}{{\tt C}}
\newcommand{\CF}{{\tt CF}}
\newcommand{\True}{\mathop{True}}
\newcommand{\False}{\mathop{False}}
\newcommand{\Bool}{\mathop{Bool}}
\newcommand{\ys}{\ol{y}}
\newcommand{\Th}[2]{{\cal T}_{#1,#2}}
\newcommand{\Ecf}{\textsc{Ecf}}


%% \conferenceinfo{ICFP'08,} {September 22--24, 2008, Victoria, BC, Canada.}
%% \CopyrightYear{2008}
%% \copyrightdata{978-1-59593-919-7/08/09} 

\title{Haskell Contracts Technical Report}

\authorinfo{}{}{} %% TBD
%% \authorinfo{Dimitrios Vytiniotis \and Simon Peyton Jones}
%%   {Microsoft Research, Cambridge}
%%   {\{dimitris,simonpj\}@@microsoft.com}
%% \authorinfo{Jos\'{e} Pedro Magalh\~{a}es}
%%   {Utrecht University}
%%   {jpm@@cs.uu.nl}


\maketitle
\makeatactive

%% \begin{abstract}
%% The Glasgow Haskell Compiler is an optimizing
%% compiler that expresses and manipulates first-class equality proofs in
%% its intermediate language.  We describe a simple, elegant technique that
%% exploits these equality proofs to support \emph{deferred type errors}.
%% The technique requires us to treat equality proofs as possibly-divergent
%% terms; we show how to do so without losing either soundness or
%% the zero-overhead cost model that the programmer expects.
%% \end{abstract}

%% \category{D.3.3}{Language Constructs and Features}{Abstract data types}
%% \category{F.3.3}{Studies of Program Constructs}{Type structure}

%% \terms{Design, Languages}

%% \keywords{Type equalities, Deferred type errors, System FC}

\newcommand{\oln}[2]{\ol{#1}^{#2}}
\newcommand{\tmar}[2]{\mathop{tmar}_{#1}(#2)}
\newcommand{\tyar}[2]{\mathop{tyar}_{#1}(#2)}

\section{Syntax and semantics}
\label{s:intro}%
We will work with a polymorphic call-by-name calculus with algebraic data types, pattern matching, 
but where (i) polymorphism is only at top-level (a-la ML), (ii) functions are $\lambda$-lifted to 
the top-level and (iii) case expressions can only occur at top level. It is easy to convert source
Haskell to this intermediate form, which simplifies our translation and formal metatheory. The 
syntax of the language is given in Figure~\ref{fig:syntax}. 

We also define an erasure on $\Delta$ which gives $\Gamma$ environments, $\Delta^{-} = \Gamma$ below:
\[\begin{array}{lrll}
(\cdot)^{-}            & = & \cdot \\
(\Delta,a)^{-}         & = & \Delta^{-} \\
(\Delta,(x{:}\tau)^{-} & = & \Delta^{-},x 
\end{array}\]

\newcommand{\ar}{\alpha}

\begin{figure}\small
\[\begin{array}{l} 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Types}} \\
\tau,\sigma & ::=  & T\;\taus & \text{Datatypes} \\ 
            & \mid & a \mid \tau -> \tau 
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Expressions}} \\
e  & ::=  & x            & \text{Variables} \\ 
   & \mid & f[\ol{\tau}] & \text{Function variables} \\ 
   & \mid & K[\ol{\tau}](\ol{e}) & \text{Data constructors} \\
   & \mid & e\;e         & \text{Applications} \\
   & \mid & @BAD@        & \text{Runtime error} \\ 
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Definitions}} \\
P   & ::= & @fix@\;(f_1^{\ar_1},...,f_k^{\ar_k})\;@=@ \\ 
    &     & \quad\quad\quad\quad (\Lambda\as_1 @.@ \lambda{\oln{x{:}\tau}{\ar_1}} @.@ u_1,...,
                                                \Lambda\as_k @.@ \lambda{\oln{x{:}\tau}{\ar_k}} @.@ u_k) \\
%% %% d   & ::= & f |-> \Lambda\ol{a} @.@ \lambda\ol{x{:}\tau} @.@ u \\ 
u   & ::= & e \mid @case@\;e\;@of@\;\ol{K\;\ol{y} -> e} \\ 
%%D   & ::= & \cdot \mid D,d \\
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Datatype declarations}} \\
dec & ::= & @data@\;T\;\ol{a} = \ol{K\;\taus}
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Type environments and signatures}} \\
\Gamma & ::=  & \cdot \mid \Gamma,x \\
\Delta & ::=  & \cdot \mid \Delta,a \mid \Delta,x{:}\tau \\
\Sigma & ::=  & \cdot \mid \Sigma,T{:}n \mid \Sigma,f{:}\forall\ol{a} @.@ \tau \mid \Sigma,K^{\ar}{:}\forall\ol{a} @.@ \oln{\tau}{\ar} -> @T@\;\as
\end{array}\\ \\
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Auxiliary functions}} \\
constrs(\Delta,T) & = & \{ K \mid (K{:}\forall \as @.@ \taus -> T\;\as) \in \Delta \} \\
%% \tyar{D}{f} & = & n & \\ 
%%             & \multicolumn{3}{l}{\text{when}\; (f |-> \Lambda\oln{a}{n} @.@ \lambda\ol{x{:}\tau} @.@ u) \in D} \\
%% \tmar{D}{f} & = & n & \\ 
%%             & \multicolumn{3}{l}{\text{when}\; (f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in D}
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Syntax of closed values}} \\
 v,w & ::= & K^\ar[\ol{\tau}](\oln{e}{\ar}) \mid f^\ar[\ol{\tau}]\;\oln{e}{m < \ar} \mid @BAD@ \\ \\ 
\end{array} \\
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Typed contracts}} \\
\Ct & ::=  & \{ (x{:}\tau) \mid e \}    & \text{Base contracts} \\ 
  & \mid &  (x{:}\Ct_1) -> \Ct_2        & \text{Arrow contracts} \\ 
  & \mid & \Ct_1 \& \Ct_2               & \text{Conjunctions}    \\ 
  & \mid & \CF                          & \text{Crash-freedom}  \\
\end{array} \\
\end{array}\]
\caption{Syntax}\label{fig:syntax}
\end{figure}


\begin{figure}\small
\[\begin{array}{c} 
\ruleform{\Sigma;\Delta |- \tau } \\ \\ 
\prooftree
         a \in \Delta
        ----------------{TVar}
         \Sigma;\Delta |- a  
        ~~~~ 
        \Sigma;\Delta |- \tau_1 \quad \Sigma;\Delta |- \tau_2
        ---------------------{TArr}
        \Sigma;\Delta |- \tau_1 -> \tau_2 
        ~~~~~ 
        \begin{array}{c}
          (T{:}n) \in \Sigma  \quad
          \Sigma;\Delta |- \taus
        \end{array}
        -------------------------{TData}
        \Sigma;\Delta |- T\;\oln{\tau}{n} 
\endprooftree \\ \\ 
\ruleform{\Sigma;\Delta |- e : \tau} \\ \\
\prooftree
  (f{:}\forall\oln{a}{n} @.@ \tau) \in \Sigma \quad \Sigma;\Delta |- \taus 
  --------------------------------------{TFVar}
  \Sigma;\Delta |- f[\oln{\tau}{n}] : \tau[\taus/\as]
  ~~~~ 
  (x{:}\tau) \in \Delta 
  --------------------------------------{TVar}
  \Sigma;\Delta |- x : \tau
  ~~~~~ 
  (K{:}\forall\oln{a}{n} @.@ \taus -> T\;\as) \in \Sigma \quad
  \Sigma;\Delta |- \taus \quad
  \Sigma;\Delta |- \ol{e : \tau}
  --------------------------------------{TCon}
  \Sigma;\Delta |- K[\oln{\tau}{n}](\ol{e}) : T\;\taus
  ~~~~~
  \phantom{\Delta}
  --------------------------------------{TBad}
  \Sigma;\Delta |- @BAD@ : \tau
  ~~~~
  \Sigma;\Delta |- e_1 : \sigma -> \tau \;\;
  \Sigma;\Delta |- e_2 : \sigma
  --------------------------------------{TApp}
  \Sigma;\Delta |- e_1\;e_2 : \tau
\endprooftree \\ \\ 
\ruleform{\Sigma;\Delta |- u : \tau} \\ \\
\prooftree
   \Sigma;\Delta |- e : \tau
   ---------------------------{TUTm}
    \Sigma;\Delta |- e : \tau
   ~~~~~ 
  \begin{array}{l}
  \Sigma;\Delta |- e : T\;\oln{\tau}{k} \quad
  constrs(\Sigma,T) = \ol{K} \\
  \text{for each branch}\;(K\;\oln{y}{l} -> e') \\
  \begin{array}{l}
           (K{:}\forall \cs @.@ \oln{\sigma}{l}{->}T\;\oln{c}{k}) \in \Sigma \text{ and }
           \Sigma;\ol{a},\ol{x{:}\tau},\ol{y{:}\sigma[\taus/\cs]} |- e'{:}\tau
  \end{array}
  \end{array}
  ----------------------------------------{TUCase}
  \Sigma;\Delta |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}
\endprooftree \\ \\ 
\ruleform{ \Sigma |- P} \\ \\ 
\prooftree
   \begin{array}{l}
   \text{ for every} (f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P \\
   \quad\quad (f{:}\forall\oln{a}{n} @.@ \oln{\tau}{m} -> \tau) \in \Sigma
   \text{ and }\Sigma;\as,\ol{x{:}\tau} |- u : \tau
   \end{array}
   ----------------------------------------------{TFDef}
   \Sigma |- P
\endprooftree 
\end{array}\]
\caption{Typing relation}\label{fig:typing}
\end{figure}

%% \begin{figure}\small
%% \[\begin{array}{c} 
%% \ruleform{D |- value(e)} \\ \\
%% \prooftree
%%    \begin{array}{c}
%%    \tmar{D}{f} > m
%%    \end{array}
%%    ------------------------------------------------{VFun}
%%     D |- value(f[\oln{\tau}{n}]\;\oln{e}{m})
%%    ~~~~~
%%    ------------------------------------------------{VCon}
%%     D |- value(K[\ol{\tau}](\ol{e}))
%%    ~~~~ 
%%    ------------------------------------------------{VBad}
%%    D |- value(@BAD@)
%% \endprooftree
%% \end{array}\]
%% \caption{Values}\label{fig:typing}
%% \end{figure}


\begin{figure*}\small
\[\begin{array}{c} 
\ruleform{P |- e \Downarrow v} \\ \\
\prooftree

-------------------------------------{EVal}
P |- v \Downarrow v
~~~~
\begin{array}{c}
(f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P \\
P |- u[\ol{\tau}/\ol{a}][\ol{e}/\ol{x}] \Downarrow v
\end{array}
-------------------------------------{EFun}
P |- f[\ol{\tau}]\;\oln{e}{m} \Downarrow v
~~~~
\begin{array}{c}  
P |- e_1 \Downarrow v_1 \quad
P |- v_1\;e_2 \Downarrow w
\end{array}
------------------------------------------------{EApp}
P |- e_1\;e_2 \Downarrow w
~~~~
\begin{array}{c}  
P |- e_1 \Downarrow @BAD@ 
\end{array}
------------------------------------------------{EBadApp}
P |- e_1\;e_2 \Downarrow @BAD@
\endprooftree \\ \\ 
\ruleform{P |- u \Downarrow v} \\ \\
\prooftree
P |- e \Downarrow v
-------------------------------------{EUTm}
P |- e \Downarrow v
~~~~ 
\begin{array}{c}
P |- e \Downarrow K_i[\ol{\sigma}_i](\ol{e}_i) \quad
P |- e'_i[\ol{e}_i/\ol{y}_i] \Downarrow w
\end{array}
------------------------------------{ECase}
P |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'} \Downarrow w
~~~~
\begin{array}{c}
P |- e \Downarrow @BAD@ \\
\end{array}
------------------------------------{EBadCase}
P |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'} \Downarrow @BAD@
%% \begin{array}{c}
%% (f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{m} @.@ @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}) \in D \\
%% D |- e[\ol{\tau}/\ol{a}][\ol{e}/\ol{x}] \Downarrow @BAD@ \\
%% \end{array}
%% -------------------------------------{EBadCase}
%% D |- f[\ol{\tau}]\;\oln{e}{m} \Downarrow @BAD@
\endprooftree
\end{array}\]
\caption{Operational semantics}\label{fig:opsem}
\end{figure*}

\begin{lemma}[Subject reduction]
Assume $\Sigma |- P$ and $\Sigma;\cdot |- e : \tau$
If $P |- e \Downarrow w$ then $P |- value(w)$ and $\Sigma;\cdot |- w : \tau$.
\end{lemma}



\newcommand{\lcf}[1]{\textsf{cf}(#1)}
\newcommand{\lcfZ}{\textsf{cf}}
\newcommand{\lncf}[1]{\neg\textsf{cf}(#1)}
\newcommand{\unr}{\mathop{unr}}
\newcommand{\bad}{\mathop{bad}}
\newcommand{\sel}[2]{\mathop{sel\_#1\!\_#2}}
\newcommand{\ctrans}[3]{{\cal C}[\![#3]\!]_{#2}^{#1}}
\newcommand{\etrans}[3]{{\cal E}[\![#3]\!]_{#2}^{#1}}
\newcommand{\utrans}[3]{{\cal U}[\![#3]\!]_{#2}^{#1}}
\newcommand{\dtrans}[2]{{\cal D}[\![#2]\!]^{#1}}
\newcommand{\Dtrans}[2]{{\cal D}[\![#2]\!]^{#1}}
%% Gadgets of domain theory 
\newcommand{\roll}{\mathsf{roll}}
\newcommand{\unroll}{\mathsf{unroll}}
\newcommand{\bind}{\mathsf{bind}}
\newcommand{\ret}{\mathsf{ret}}
\newcommand{\dlambda}{\mathsf{\lambda}}
\newcommand{\curry}{\mathsf{curry}}
\newcommand{\eval}{\mathsf{eval}}
\newcommand{\uncurry}{\mathsf{incurry}}
\newcommand{\dapp}{\mathsf{app}}
\newcommand{\inj}[1]{\mathsf{inj}_{#1}}

\begin{lemma}[Value determinacy]
If $\Sigma;\cdot |- v : \tau$ and 
$\Sigma |- P$ and $P |- value(v)$ and $P |- v \Downarrow w$ then $ v = w $.
\end{lemma}

\begin{lemma}[Determinacy of evaluation]
If $\Sigma;\cdot |- e : \tau$ and 
$\Sigma |- P$ and $\Sigma;\cdot |- e \Downarrow v_1$ and $\Sigma;\cdot |- e \Downarrow v_2$ then
$v_1 = v_2$.
\end{lemma}

\begin{lemma}[Big-step soundness]
If $\Sigma;\cdot |- e : \tau$ and 
$\Sigma |- P$ and $\Sigma;\cdot |- e \Downarrow v$ then $P |- value(v)$ and $\Sigma;\cdot |- v : \tau$.
\end{lemma}


\section{Denotational semantics}
\newcommand{\unitcpo}{{\sf{\bf 1}}}

For a well-formed signature $\Sigma$, we define the strict bi-functor on cpos, below, 
assuming that $K_1\ldots K_k$ are all the constructors in $\Sigma$: 
\[\begin{array}{lclll}
  F_{\Sigma}(D^{-},D^{+}) & = & ( \quad{\prod_{\alpha_1}{D^{+}}} & K_1^{\ar_1} \in \Sigma \\
                      & + & \;\quad\ldots                    & \ldots \\
                      & + & \;\quad{\prod_{\alpha_k}{D^{+}}} & K_k^{\ar_k} \in \Sigma \\ 
                      & + & \;\quad(D^{-} =>_c D^{+}) \\
                      & + & \;\quad\unitcpo_{bad} \quad )_{\bot}
\end{array}\] 
The notation $\prod_{n}{D}$ abbreviates $n$-ary products ($\unitcpo$ if $n = 0$). The product
and sum constructions are standard, and not strict. The notation $C =>_c D$ denotes the cpo 
induced by the space of continus functions from the cpo $C$ to the cpo $D$. We use $\unitcpo_{bad}$ 
notation to simply denote a single-element cpo -- the $bad$ subscript is just there for readability. 

The notation $D_\bot$ is {\em lifting}, which is a monad, equipped with the following two continuous functions.
\[\begin{array}{l}
   \ret   : D =>_c D_\bot \\ 
   \bind_{f : D =>_c E_\bot} : D_\bot =>_c E_\bot
\end{array}\]
with the obvious definitions.

Moreover, the following continuous operations are defined:
\[\begin{array}{l} 
   \curry_{f : D\times E =>_c F} : D =>_c (E =>_C F) \\ 
   \eval : (E =>_c D)\times E =>_c D 
\end{array}\] 
for any cpos $D, E, F$.

\begin{lemma}\label{lem:rec-solution} 
There exists a solution to the domain-recursive equation induced by $F_{\Sigma}$, call it $D_{\infty}$.
Moreover, let a value-domain: $V_{\infty}$ be defined as:
    \[\begin{array}{ll}
             \quad\;{\prod_{\alpha_1}{D_{\infty}}} & K_1^{\ar_1} \in \Sigma \\
             \; + \;\ldots                    & \ldots \\
             \; + \;{\prod_{\alpha_k}{D_{\infty}}} & K_k^{\ar_k} \in \Sigma \\ 
             \; + \;(D_{\infty} =>_c D_{\infty}) \\
             \; + \;\unitcpo_{bad} \quad
    \end{array}\]
Then the following functions also exist, each being the inverse of the other (i.e. composing to the identity 
function on the appropriate cpo):
\[\begin{array}{l}
  \roll : (V_{\infty})_\bot =>_c D_{\infty} \\ 
  \unroll : D_{\infty} =>_c (V_{\infty})_\bot
\end{array}\] 
\end{lemma}

We summarize the (standard) construction needed for the proof of Lemma~\ref{lem:rec-solution} based on embedding-projection pairs, 
because some of its details will be useful later. Consider the chain of cpos $D_i$ defined as: 
\[\begin{array}{lcl}
   D_0 & = & \{\bot\} \\ 
   D_{i+1} & = & F_{\Sigma}(D_i,D_i)
\end{array}\]
and moreover consider the corresponding {\em embeddings} $e_i : D_i =>_c D_{i+1}$ and 
{\em projections} $p_i : D_{i+1} =>_c D_i$ defined as:
\[\begin{array}{lcl}
   e_0 & = & \dlambda d @.@ \bot_{D_1} \\
   p_0 & = & \dlambda d @.@ \bot_{D_0} \\
   e_{i+1} & = & F_{\Sigma}(p_i,e_i) \\
   p_{i+1} & = & F_{\Sigma}(e_i,p_i)
\end{array}\]
The following is an easy fact to prove:
\begin{lemma}
For every $i$ and $x$ element of $D_i$ we have $p_i\cdot e_i(x) = x$. For
every $y$ element of $D_{i+1}$ we have that $e_i\ cdot p_i(y) \sqsubseteq y$. 
\end{lemma}
Consider now the cpo defined by the carrier set 
   \[ \{ x \in \Pi_{i \in \omega}D_i \;\mid\; x_n = p_n(x_{n+1}) \} \] 
and the pointwise order induced by the order in each $D_i$, and $\bot$ element the 
infinite tuple of the corresponding $\bot$ elements. This cpo {\em is} going to be the 
set $D_{\infty}$. To prove this we need som more definitions. Let $j_{n,m} : D_n =>_c D_m$ 
be defined as:
\[\begin{array}{lcl}
   j_{n,m}(d) & = & \left\{\begin{array}{ll} 
                             e_{m-1}\cdot\ldots \cdot e_n(d) & n < m \\
                             d                        & n = m \\
                             p_{n-1}\cdot\ldots \cdot p_n(d) & n > m 
                          \end{array}\right.
\end{array}\]
and define $j_i : D_i =>_c D_\infty$ as:
\[\begin{array}{lcl}
   j_i(d) & = & \langle j_{i,0}(d),j_{i,1}(d),\ldots \\
\end{array}\]
We can easily show that $j_i$ and $\pi_i$ (the $i$-th projection from a tuple) form
an embedding-projection pair:
\begin{lemma}
For all $i$ and $x$ element of $D_{\infty}$ it is $j_i(\pi_i(x)) \sqsubseteq x$.
For all $y$ element of $D_{i}$ it is $\pi_i(j_i(y)) = y$.
\end{lemma}
The most important theorem is that the limit of $j_i\cdot\pi_i$ is the identity.
\begin{lemma}\label{lem:id-sqcup}
For all $x$ elements of $D_{\infty}$ it is $\sqcup(j_i\cdot\pi_i)(x) = x$.
\end{lemma}
\begin{proof} We have one direction by the previous lemma and least upper bounds.
So the hard direction is to show that $\sqcup(j_i\cdot\pi_i)(x) \sqsupseteq x$. 
We know that:
\[       \pi_n(j_n(\pi_n(d))) = \pi_n(d) \]
by unfolding definitions and we know that $\sqcup(j_n\cdot\pi_n) \sqsupseteq j_n\cdot\pi_n$
since it is a least upper bound. By monotonicity we then get that 
\[      \pi_n(\sqcup(j_n\cdot\pi_n)(d)) \sqsupseteq \pi_n(d) \] 
but that holds for ever $n$ which means that:
\[       \sqcup(j_n\cdot\pi_n)(d) \sqsupseteq d \] 
since $\sqsubseteq$ on $D_\infty$ is defined by the conjuction of the 
pointwise $\sqsubseteq$ on each $D_i$.
\end{proof}
Now let us consider the chain 
\[ F_{\Sigma}(D_0,D_0) \quad F_{\Sigma}(D_1,D_1) \quad \ldots \] 
and the pointed cpo $F_{\Sigma}(D_{\infty},D_{\infty})$ we have that:
\[\begin{array}{lcl}
    F_{\Sigma}(p_i,e_i)   & : & F(D_i,D_i) =>_c F(D_{i+1},D_{i+1}) \\ 
    F_{\Sigma}(\pi_i,j_i) & : & F(D_i,D_i) =>_c F(D_{\infty},D_{\infty})
\end{array}\] 
we will show that there exists an isomorphism $D_\infty \cong F_{\Sigma}(D_\infty,D_\infty)$.

\begin{lemma} Define functions $\roll = \sqcup(j_{i+1}\cdot F_{\Sigma}(j_i,\pi_i))$ and 
$\unroll = \sqcup (F_{\Sigma}(\pi_i,j_i)\cdot \pi_{i+1})$. They form the required isomorphism 
$D_\infty \cong F_{\Sigma}(D_\infty,D_\infty)$.
\end{lemma}
This lemma concludes the proof of Lemma~\ref{lem:rec-solution}.

The following fact will be extremely useful in establishing the existence of solutions
to recursive equations {\em over} the recursively defined domain via approximating the
denotations. Let us call $\rho_i = j_i\cdot\pi_i$. 

\begin{theorem}\label{lem:min-inv-reqs} The following are true:
\begin{itemize} 
   \item $\unroll \cdot \rho_{i+1} \cdot \roll = F_{\Sigma}(\rho_i,\rho_i)$ 
   \item $\sqcup\rho_i(d) = d$, for all elements $d$ of $D_{\infty}$.
\end{itemize}
\end{theorem}

\paragraph{Definability of application}
We may now {\em define} application $\dapp : D_\infty \times D_\infty =>_c D_\infty$ as: 
{\setlength{\arraycolsep}{2pt}
\[\begin{array}{rcll}
   \dapp & = & \multicolumn{2}{l}{\dlambda d @.@ \roll(\bind_g (\unroll (\pi_1(d))))} \\
   \text{ where } g & = &  [ & \bot : \prod_{\ar_1}{D_\infty} =>_c D_\infty =>_c (V_\infty)_\bot \\
                    &   &  , & \ldots \\
                    &   &  , & \bot : \prod_{\ar_k}{D_\infty} =>_c D_\infty =>_c (V_\infty)_\bot \\
                    &   &  , & \dlambda d' @.@ \unroll(d'(\pi_2(d))) \\
                    &   &  , & \dlambda b @.@ \dlambda d. \ret(\inj{bad}(b))\hspace{2pt} ] 
\end{array}\]}%
where we have used notation $\langle , \rangle$ to introduce pairs. and $[\ldots]$ to eliminate ($n$-ary) sums.
The projections $\pi_1$ and $\pi_2$ are the obvious continues projections from the binary product space of $D_{\infty}$. 
We use notation $\inj{K}$ to denote the continuous map that injects some $\alpha$-ary product of $D_{\infty}$ into the sum $V_{\infty}$.
We use notation $\inj{->}$ to denote the continuous injection of $(D_{\infty} =>_c D_{\infty})$ into $V_{\infty}$ and finally, 
$\inj{bad}$ for the unit injection into $V_{\infty}$.


\subsection{Interpretations}
\newcommand{\VarCpo}{\textit{Var}}
\newcommand{\FVarCpo}{\textit{FunVar}}
\newcommand{\interp}[3]{[\![#1]\!]_{\langle {#2},{#3}\rangle}}
\newcommand{\dbrace}[1]{[\![#1]\!]}


We have now defined the domain-theoretic language and combinators that we will use. 
We proceed to give interpretations of terms and definitions. 

First, the denumerable set of term variable names $x_1,\ldots$ induces a discrete 
cpo $\VarCpo$  and the denumerable set of function variable names $f_1,\ldots$ induces a discrete 
cpo $\FVarCpo$. We define, {\em semantic term environments} to be the cpo $(\VarCpo =>_c D_{\infty})$, 
and {\em semantic function environments} to be the cpo $(\FVarCpo =>_c D_{\infty})$. 

Next we will define $[\![e]\!]$ as a continuous map: 
\[ 
    (\FVarCpo =>_c D_{\infty}) \times (\VarCpo =>_c D_{\infty}) =>_c D_{\infty}
\] 
Below, for a given term $e$ and semantic environments $\rho : \VarCpo =>_c D_{\infty}$ and 
$\sigma : \FVarCpo =>_c D_{\infty}$ we let: 
\[\begin{array}{rcll}
  \interp{x}{\sigma}{\rho} & = & \rho(x) \\ 
  \interp{f\;[\taus]}{\sigma}{\rho} & = & \sigma(f) \\
  \interp{K\;[\taus]\;(\ol{e})}{\sigma}{\rho} & = & \roll(\ret(\inj{K}(\langle\interp{\ol{e}}{\sigma}{\rho}\rangle))) \\ 
  \interp{e_1\;e_2}{\sigma}{\rho} & = & \dapp(\langle \interp{e_1}{\sigma}{\rho}, \interp{e_2}{\sigma}{\rho}\rangle) \\ 
  \interp{@BAD@}{\sigma}{\rho} & = & \roll(\ret(\inj{bad}1))
\end{array}\]
A small technical remark: we write this with pattern matching notation (instead of using $\pi_1$ for projecting 
out $\sigma$ and $\pi_2$ for projecting out $\rho$) but that is fine, since $\times$ is not a lifted construction. 

Proceeding in the same way for $[\![u]\!]$ we get:
\[\setlength{\arraycolsep}{2pt}
  \begin{array}{rcll}
  \interp{e}{\sigma}{\rho} & = & \multicolumn{2}{l}{\interp{e}{\sigma}{\rho}} \\ 
  \interp{@case@\;e\;@of@ \ol{ K\;\ys -> e_K}}{\sigma}{\rho} & = & \multicolumn{2}{l}{\roll(\bind_{g} (\unroll(\interp{e}{\sigma}{\rho})))} \\ \\ 
  \text{ where } g  & = & [ & h_{K_1} \\
                    &   & , & \ldots \\
                    &   & , & h_{K_k} \\
                    &   & , & \bot \\ 
                    &   & , & \dlambda b @.@ \ret(b) \hspace{2pt} ] \\ 
              h_{K} & =  & \multicolumn{2}{l}{\dlambda d @.@ \unroll(\interp{e_K}{\sigma}{\rho, \ol{y |-> \pi_i(d)}})} \\ 
                    &   & \multicolumn{2}{l}{\text{when } K \text{ is in the branches}} \\
              h_{K}  & = & \multicolumn{2}{l}{\bot } \\ 
                    &   & \multicolumn{2}{l}{\text{otherwise}}                  
\end{array}\]

Finally, for a definition $P$ we may define a continuous map:
\[ 
        [\![P]\!] : (\FVarCpo =>_c D_{\infty}) =>_c (\FVarCpo =>_c D_{\infty}) 
\]
Let $P$ be 
\[\begin{array}{l} 
     @fix@\;(f_1^{\ar_1},...,f_k^{\ar_k})\;@=@\; 
     (\lambda{\oln{x{:}\tau}{\ar_1}} @.@ u_1,...,
                   \Lambda\as_k @.@ \lambda{\oln{x{:}\tau}{\ar_k}} @.@ u_k) 
\end{array}\] 
Then
\[\begin{array}{l}  
   [\![P]\!]_{\sigma} f =  \\ 
     \qquad\text{ if } (f |-> \Lambda\as @.@ \lambda\oln{x:\tau}{n} @.@ u) \in P \\
     \qquad\text{ then } \\
     \qquad\quad\quad \roll(\ret(\inj{->}(\dlambda d_1 @.@ \ldots  \\
     \qquad\quad\quad\quad \roll(\ret(\inj{->}(\dlambda d_n @.@ \interp{u}{\sigma}{\ol{x |-> d}})))\ldots))) \\
     \qquad \text{ else } \bot
\end{array}\]

Since $[\![P]\!]$ is continuous, its limit exists and is an element of the cpo $\FVarCpo =>_c D_{\infty}$, 
we will call this $\dbrace{P}^{\infty}$ in what follows.


\begin{lemma}[Type irrelevance]
It is the case that $\interp{u}{\sigma}{\rho} = \interp{u[\ol{\tau}/\as]}{\sigma}{\rho}$ 
and $\interp{e}{\sigma}{\rho} = \interp{e[\ol{\tau}/\as]}{\sigma}{\rho}$.
\end{lemma}
\begin{proof} Straightforward induction. \end{proof}

\begin{lemma}[Substitutivity]
If $\Sigma;\Delta,x{:}\tau |- e : \tau$ and $\rho$ is a semantic environment 
and $\Sigma;\Delta |- e' : \tau'$ then 
\[ \interp{e}{\sigma}{\rho,x |-> \interp{e'}{\sigma}{\rho}} = \interp{e[e'/x]}{\sigma}{\rho} \]
and if $\Sigma;\Delta,x{:}\tau |- u : \tau$ then 
\[ \interp{u}{\sigma}{\rho,x |-> \interp{e'}{\sigma}{\rho}} = \interp{u[e'/x]}{\sigma}{\rho} \]
\end{lemma}

\begin{lemma}[Denotational semantics soundness]
Assume $\Sigma |- P$. 
\begin{itemize*} 
  \item If $\Sigma;\cdot |- e : \tau$ and $P |- e \Downarrow v$ then $\interp{e}{\dbrace{P}^{\infty}}{\cdot} = \interp{v}{\dbrace{P}^{\infty}}{\cdot}$.
  \item If $\Sigma;\cdot |- u : \tau$ and $P |- u \Downarrow v$ then $\interp{u}{\dbrace{P}^{\infty}}{\cdot} = \interp{v}{\dbrace{P}^{\infty}}{\cdot}$.
\end{itemize*} 
\end{lemma} 
\begin{proof} The two statements are proved simultaneously by induction on the height of the evaluation derivation, making use
of the type irrelevance lemma and substitutivity.
\end{proof}

\subsection{Adequacy}
The goal of this section is to prove the following lemma: 

\begin{theorem}[Computational adequacy]
Assume $\Sigma |- P$ and $\Sigma;\cdot |- e : \tau$. 
If $\unroll(\interp{e}{\dbrace{P}^{\infty}}{\cdot}) = \ret(d)$ for some 
element $d$ of $V_{\infty}$ then there exists a $v$ such 
that $P |- e \Downarrow v$.
\end{theorem}

To do this we define a {\em logical relation} first between semantics 
and syntax. Let $Rel \subseteq D_\infty \times Expr$ be the space of 
{\em admissible} and {\em equality-respecting} relations between 
denotations and closed (non-necessarily well-typed) terms. Some explanations:
\begin{itemize}
  \item $R \in Rel$ is {\em admissible} iff whenever 
  $R(d_i,e)$ for every element of a chain $d_1\ldots$ then also $R(\sqcup_{\omega}d_i,e)$. 
  \item $R \in Rel$ is {\em equality-respecting} iff for every 
  $R(d,e)$ and $d' = d$ (according to the equality on $D_{\infty}$) it also is
  $R(d',e)$. 
\end{itemize}

Let use define the following bi-functor on the space of $Rel$ relations:
{\setlength{\arraycolsep}{2pt}
\[\begin{array}{lcl}
   F_{P}(R^{-},R^{+}) & = & \{ (d,e)\;\mid\;\forall \ol{d} @.@ \unroll(d) = \ret(\inj{K_1^\ar}\langle\oln{d}{\ar}\rangle) ==> \\
                   &   & \quad \exists \oln{e}{\ar} @.@ P |- e \Downarrow K_1[\taus](\ol{e}) \land (d_i,e_i) \in R^{+} \} \\ 
                   & \cup & \ldots \\ 
                   & \cup & \{ (d,e)\;\mid\;\forall d_0 @.@ \unroll(d) = \ret(\inj{->}(d_0)) ==> \\ 
                   &   & \quad \exists v @.@ P |- e \Downarrow v \;\land \\ 
                   &  & \quad\quad \forall (d',e') \in R^{-} @.@ (\dapp(d,d'),v\;e') \in R^{+} \}  \\
                   & \cup & \{ (d,e)\;\mid\; \unroll(d) = \ret(\inj{bad}(1)) ==> \\ 
                   &   & \quad P |- e \Downarrow @BAD@ \} 
\end{array}\]}

\begin{lemma} There exists negative and a positive fixpoint of $F_{P}$ and they coincide: let us call this
$F_{P}^\infty$ -- it is isomorphic to $F_{P}(F_P^\infty,F_P^\infty)$.
\end{lemma}
\begin{proof}
We can follow the standard roadmap described in the work of Pitts to show this, taking 
advantage of the approximation on every element of $D_{\infty}$ given in 
Lemma~\ref{lem:min-inv-reqs}.
\end{proof}

\begin{lemma}\label{lem:bot-in-fix}
$(\roll(\bot),e) \in F_{P}^\infty$. \end{lemma}

\begin{lemma}\label{lem:eval-respecting}
If $(d,e) \in F_{P}^\infty$ and $P |- e \Downarrow v$ then $(d,v) \in F_{P}^\infty$.
Moreover, if $(d,v) \in F_{P}^\infty$ and $P |- e \Downarrow v$ then $(d,e) \in F_{P}^\infty$.
\end{lemma}
\begin{proof}
For the first part, 
if $(d,e) \in F_{P}^\infty$ then $(d,e) \in F_{P}(F_{P}^\infty,F_{P}^\infty)$. 
By the definition of $F_{P}(\cdot,\cdot)$ and by rule \rulename{EVal} the 
result follows. The second part is a similar case analysis.
\end{proof}

\begin{lemma}[Fundamental theorem for expressions]\label{lem:fund-thm-exp}
For all $\sigma$ such that $(\sigma(f),f\;[\taus]) \in F_P^\infty$ and 
all $\rho$ and vectors of closed terms $\ol{e}$ such that $(\rho(x_i),e_i) \in F_P^\infty$ 
and all $e$ with free variables in $\ol{x}$ it must be the case 
that $(\interp{e}{\sigma}{\rho},e[\ol{e}/\ol{x}]) \in F_P^\infty$.
\end{lemma}
\begin{proof} The proof is by induction on $e$. 
\begin{itemize}
  \item Case $e = x_i$ for some $x_i \in \ol{x}$ follows by the assumptions.
  \item Case $e = f\;[\taus]$ for some $f$ follows by assumptions.
  \item Case $e = K^\ar[\taus](\oln{e'}{\ar})$. By induction hypothesis we 
  have that for each $e'_i$ it is $(\interp{e'_i}{\sigma}{\rho},e'_i[\ol{e}/\ol{x}]) \in F_P^\infty$ and 
  by using rule \rulename{EVal} we are done since 
      \[ \interp{K^{\ar}[\taus](\oln{e'}{\ar})}{\sigma}{\rho} = \roll(\ret(\inj{K}(\langle\ol{\interp{e'_i}{\sigma}{\rho}}\rangle))) \]
  \item Case $e = @BAD@$ follows by unfolding definitions.
  \item Case $e = e_1\;e_2$. We need to show that
     \[ (\interp{e_1\;e_2}{\sigma}{\rho},e_1[\ol{e}/\ol{x}]\;e_2[\ol{e}/\ol{x}]) \in F_P^\infty \] 
  By induction hypothesis we have that 
  \begin{eqnarray}
     (\interp{e_1}{\sigma}{\rho},e_1[\ol{e}/\ol{x}]) \in F_P^\infty \label{eqn:e1} \\ 
     (\interp{e_2}{\sigma}{\rho},e_2[\ol{e}/\ol{x}]) \in F_P^\infty \label{eqn:e2}
  \end{eqnarray}
  Equation~\ref{eqn:e1} gives four cases: First, if $\interp{e_1}{\sigma}{\rho} = \roll(\bot)$ then we 
  are done since $\dapp(\bot,\_) = \roll(\bot)$ and $(\roll(\bot), e_1\;e_2) \in F_P^\infty$ by Lemma~\ref{lem:bot-in-fix}.
  Second, if $\interp{e_1}{\sigma}{\rho} = \roll(\ret(\inj{K}(\langle\ol{d}\rangle)))$ for some constructor
  $K$ then $\dapp(\interp{e_1}{\sigma}{\rho},\_) = \roll(\bot)$ and by similar reasoning as above we are done.
  Third, if $\interp{e_1}{\sigma}{\rho} = \roll(\ret(\inj{bad}(1)))$ then it must be that $P |- e_1[\ol{e}/\ol{x}] \Downarrow @BAD@$ by
  induction hypothesis, and by rule \rulename{EBadApp} we know that $P |- e_1[\ol{e}/\ol{x}]\;e_2[\ol{e}/\ol{x}] \Downarrow @BAD@$ hence, 
  by Lemma~\ref{lem:eval-respecting} we are done. The final case is the interesting one, where
  $\interp{e_1}{\sigma}{\rho} = \roll(\ret(\inj{->}(d_0)))$ in which case by induction hypothesis we know that 
  $(d_0(\interp{e_2}{\sigma}{\rho}), v\;e_2[\ol{e}/\ol{x}]) \in F_P^\infty$ for $P |- e_1[\ol{e}/\ol{x}] \Downarrow v$. But we know that 
  $v\;e_2[\ol{e}/\ol{x}]$ evaluates to a value {\em iff} $e_1[\ol{e}/\ol{x}]\;e_2[\ol{e}/\ol{x}]$ evaluates to a value and by 
  Lemma~\ref{lem:eval-respecting} we are done.
\end{itemize}
\end{proof}


\begin{lemma}[Fundamental theorem for top-level expressions]\label{lem:fund-thm-case}
For all $\sigma$ such that $(\sigma(f),f\;[\taus]) \in F_P^\infty$ and 
all $\rho$ and vectors of closed terms $\ol{e}$ such that $(\rho(x_i),e_i) \in F_P^\infty$ 
and all $u$ with free variables in $\ol{x}$ it must be the case 
that $(\interp{u}{\sigma}{\rho},u[\ol{e}/\ol{x}]) \in F_P^\infty$.
\end{lemma}
\begin{proof} By induction on $u$. If $u$ is a term $e$ then we are immediately done
by Lemma~\ref{lem:fund-thm-exp}. If $u = @case@\;e\;@of@\;\ol{K\;\ys -> e'}$ then the 
result follows by appealing to the induction hypothesis for $e$ and performing a case 
analysis on $\interp{e}{\sigma}{\rho}$ -- in the interesting case we appeal further to
Lemma~\ref{lem:fund-thm-exp} for a matching $e_K$ and the evaluation-respecting lemma, 
Lemma~\ref{lem:eval-respecting}.
\end{proof}

Finally, for the recursive functions environment $P$ we prove the following.
\begin{lemma} For any $f$, $(\dbrace{P}^\infty(f),f\;[\taus]) \in F_P^\infty$. \end{lemma}
\begin{proof}
Since $F_P^\infty$ is itself an {\em admissible} relation, we need only prove that:
\[ \forall i @.@ \forall f @.@ (\dbrace{P}^i(f),f\;[\taus]) \in F_P^\infty \] 
which we do by induction on $i$. For $i = 0$ we are immediately done by Lemma~\ref{lem:bot-in-fix}.
Let us assume that the property is true for $i$. We must show it is true for $i+1$. That is, 
we must show that $(\dbrace{P}^{i+1}(f),f\;[\taus]) \in F_P^\infty$. Hence, if $f$ has arity $n$, by
the definition of $\dbrace{P}$ and the definition of the logical relation it is enough to show that
for all $(\oln{d}{n},\oln{e}{n}) \in F_P^\infty$ it must be the case that 
\[    (\interp{u}{\dbrace{P}^i}{\ol{x |-> d}}, u[\ol{e}/\ol{x}]) \in F_P^\infty \] 
for $f |-> (\Lambda\as @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in P$. But that follows by 
Lemma~\ref{lem:fund-thm-case}, since by induction hypothesis it is the case that for 
every $f$ we have $(\dbrace{P}^i(f),f\;[\ol{\tau}]) \in F_P^\infty$.
\end{proof} 

\begin{corollary}\label{cor:fund-thm-top}
For every closed expression $e$ in $P$ (not-necessarily well-typed) we have that 
$(\interp{e}{\dbrace{P}^\infty}{\cdot}, e) \in F_P^\infty$. 
\end{corollary}

From this corollary, adequacy follows by unfolding definitions.

\begin{corollary}[Model-based-reasoning]
If $\Sigma |- P$ and $\Sigma;\cdot |- e_1 : \tau$ and $\Sigma;\cdot |- e_2 : \tau$, 
then for every closed $e$ such that $\Sigma |- P$ and $\Sigma;\cdot |- e : \tau -> Bool$,
if $\interp{e_1}{\dbrace{P}^\infty}{\cdot} = \interp{e_2}{\dbrace{P}^\infty}{\cdot}$ then  
$P |- e\;e_1 \Downarrow$ iff $P |- e\;e_2 \Downarrow$. 
\end{corollary}
\begin{proof}
For one direction assume that $P |- e\;e_1 \Downarrow w$, hence by computational soundness it must be that 
$\interp{e\;e_1}{\dbrace{P}^\infty}{\cdot} = \roll(\ret(d))$. By assumptions we must also 
have that $\interp{e\;e_2}{\dbrace{P}^\infty}{\cdot} = \roll(\ret(d))$. By the fundamental theorem 
we know that 
\[ (\interp{e\;e_2}{\dbrace{P}^\infty}{\cdot}, e\;e_2) \in F_{P}^\infty \] 
and hence $P |- e\;e_2 \Downarrow$. The other direction is symmetric.
\end{proof}

%% \begin{lemma}[Evaluation preserves equality]
%% If $\Sigma;\cdot |- e : \tau \rightsquigarrow t$ and 
%%    $\Sigma |- D \rightsquigarrow \phi_{\Sigma,D}$ and 
%%    $D |- e \Downarrow w$ then
%%    $\Sigma;\cdot |- w : \tau \rightsquigarrow s$ and $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- t = s$.
%% \end{lemma}
%% \begin{proof} By induction on the evaluation $\Sigma |- e \Downarrow w$. \end{proof}


%% \begin{lemma}[Logic deduces sound value equalities]
%% Assume that $\Sigma;\cdot |- w : \tau \rightsquigarrow t$ and 
%% $D |- value(w)$ and $\Sigma |- D \rightsquigarrow \phi_{\Sigma,D}$. 
%% Then
%% \begin{enumerate*} 
%%   \item If $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- t = \bad$ then $w = @BAD@$.
%%   \item If $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- t = K(\ol{t})$ then $w = K[\taus](\ol{e})$, such 
%%         that $\Sigma;\cdot |- \ol{e : \tau} \rightsquigarrow \ol{s}$, and $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- \ol{t = s}$.
%%   \item $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- t \neq \unr$.
%% \end{enumerate*}
%% \end{lemma}
%% \begin{proof}
%% The proof of all three cases is by inversion on the $D |- value(w)$ derivation, 
%% apealling to the disjointness axioms.
%% %% \begin{enumerate*}
%% %%   \item By inversion on the $D |- value(w)$ derivation. In the case of \rulename{VBad} we are done.
%% %%   The case of \rulename{VFun} cannot happen, by the axiom set \rulename{AxPartB}. The case of \rulename{VCon} 
%% %%   cannot happen either: If the application is saturated then \rulename{AxDisjC} shows it is impossible; if it
%% %%   is not saturated we can always extend it and use \rulename{AxAppC} and \rulename{AxDisjC}. 
%% %%   \item Again by inversion on $D |- value(w)$ derivation. The case of \rulename{VBad} is easy. The case for 
%% %%   \rulename{VCon} follows by injectivity of constructors. The case of \rulename{VFun} can't happen by 
%% %%   \rulename{AxPartB}.
%% %%   \item Direct inversion on $D |- value(w)$, and using disjointness axioms.
%% %% \end{enumerate*} 
%% \end{proof}
 
%% Basic soundness will be stated as follows.
%% \begin{theorem}
%% If we have that
%% \begin{enumerate*} 
%%   \item $\Sigma;\cdot |- e : \tau$ and $\Sigma;\cdot |- \Ct : \tau$
%%   \item $\Sigma |- D \rightsquigarrow \phi_{\Sigma,D}$
%%   \item $\Sigma;\cdot |- e \in \Ct \rightsquigarrow \phi$
%% \end{enumerate*}
%% and $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} /\ \neg \phi$ is unsatisfiable then $\Sigma;D |- e \in \Ct$.
%% \end{theorem}
%% \begin{proof}
%%  {\bf TODO}
%% \end{proof}

%% A remark: a formula $\phi$ is unsatisfiable iff $\neg \phi$ is valid in FOL. Hence, if 
%% $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} /\ \neg \phi$ is unsatisfiable then 
%% $\neg (\Th{\Sigma}{D} /\ \phi_{\Sigma,D}) \lor \phi$ must be valid, and by completeness of FOL, 
%% $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- \phi$.  

\section{Denotational semantics as FOL models} 
\newcommand{\linterp}[1]{{\cal I}(#1)}
\newcommand{\lassign}[1]{\mu(#1)}


\begin{figure}
\[\begin{array}{c} 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Terms}} \\
  s,t & ::=  & f(\ol{t}) \mid K(\ol{t}) \mid x & \text{Functions, constructors, vars} \\
      & \mid & \sel{K}{i}                      & \text{Constructor selectors} \\ 
      & \mid & app(t,s)                        & \text{Application} \\
      & \mid & \unr \mid \bad                  & \text{Unreachable, bad} \\ \\ 
\multicolumn{3}{l}{\text{Formulae}} \\ 
 \phi & ::=  & \lcf{t}    & \text{Provably cannot cause crash} \\
%%      & \mid & \lncf{t}   & \text{Can provably cause crash} \\
      & \mid & t_1 = t_2  & \text{Equality} \\ 
      & \mid & \phi \land \phi \mid \phi \lor \phi \mid \neg \phi \\
      & \mid & \forall x @.@ \phi \mid \exists x @.@ \phi \\ \\ 
\multicolumn{3}{l}{\text{Abbreviations}} \\ 
\multicolumn{4}{l}{app(t,\oln{s}{n}) = (\ldots(app(t,s_1),\ldots s_n)\ldots)}
\end{array}
\end{array}\]
\caption{Image of translation into FOL}\label{fig:fol-image}
\end{figure}

\newcommand{\elab}[1]{\rightsquigarrow \formula{#1}}

\begin{figure}\small
\[\begin{array}{c} 
\ruleform{\etrans{\Sigma}{\Gamma}{e} = \formula{t} } \\ \\
\prooftree
  \begin{array}{c}
  (f{:}\forall\oln{a}{n} @.@ \tau) \in \Sigma
  \end{array}
  --------------------------------------{TFVar}
  \etrans{\Sigma}{\Gamma}{f[\oln{\tau}{n}]} = \formula{f_{ptr}}
  ~~~~ 
  x \in \Gamma 
  --------------------------------------{TVar}
  \etrans{\Sigma}{\Gamma}{x} = \formula{x}
  ~~~~~ 
  \begin{array}{c}
  (K{:}\forall\oln{a}{n} @.@ \ol{\tau} -> T\;\as) \in \Sigma \quad
  \ol{\etrans{\Sigma}{\Gamma}{e} = \formula{t}}
  \end{array}
  --------------------------------------{TCon}
  \etrans{\Sigma}{\Gamma}{K[\oln{\tau}{n}](\ol{e})} = \formula{K(\ol{t})}
  ~~~~~
  \phantom{\Gamma}
  --------------------------------------{TBad}
  \etrans{\Sigma}{\Gamma}{@BAD@} = \formula{\bad}
  ~~~~
  \etrans{\Sigma}{\Gamma}{e_1} = \formula{t_1} \quad 
  \etrans{\Sigma}{\Gamma}{e_2} = \formula{t_2}
  --------------------------------------{TApp}
  \etrans{\Sigma}{\Gamma}{e_1\;e_2} = \formula{app(t_1,t_2)}
\endprooftree \\ \\ 
\ruleform{\utrans{\Sigma}{\Gamma}{t \sim u} = \formula{\phi}} \\ \\ 
\prooftree
   \etrans{\Sigma}{\Gamma}{e} = \formula{t}
   ----------------------------------------{TUTm}
   \utrans{\Sigma}{\Gamma}{s \sim e } = \formula{s = t} 
   ~~~~~
  \begin{array}{l}
  \etrans{\Sigma}{\Gamma}{e} = \formula{t} \quad
  constrs(\Sigma,T) = \ol{K} \\
  \text{for each branch}\;(K\;\oln{y}{l} -> e') \\
  \begin{array}{l}
           (K{:}\forall \cs @.@ \oln{\sigma}{l} -> T\;\oln{c}{k}) \in \Sigma \text{ and }
           \etrans{\Sigma}{\Gamma,\ol{y}}{e'} = \formula{ t_K }
  \end{array}
  \end{array}
  ------------------------------------------{TUCase}
  \begin{array}{l}
  \utrans{\Sigma}{\Gamma}{s \sim @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}} = \\
  \;\;\formula{ \begin{array}{l} (t = \bad /\ s = \bad)\;\lor\;(s = \unr)\;\lor \\
                                \quad      \bigvee(t = K(\oln{{\sel{K}{i}}(t)}{}) \land
                                           s = t_K[\oln{\sel{K}{i}(t)}{}/\ol{y}])
                   \end{array}
           }
  \end{array}
\endprooftree \\ \\ 
\ruleform{ \Dtrans{\Sigma}{P} = \formula{\phi}} \\ \\ 
\prooftree
     \begin{array}{l}       
       \text{for each} (f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P \\ 
          \quad \utrans{\Sigma}{\ol{x}}{f(\ol{x}) \sim u} = \formula{\phi}
     \end{array}
     --------------------{TDefs}
     \Dtrans{\Sigma}{P} = \bigwedge_{P} \formula{\forall \ol{x} @.@ \phi}
\endprooftree 

\end{array}\]
\caption{Well-scoped elaboration to FOL terms}\label{fig:etrans}
\end{figure}

%% \begin{figure}\small
%% \[\begin{array}{c} 
%% %% \ruleform{ \dtrans{\Sigma}{d} = \formula{\phi} } \\ \\
%% %% \prooftree
%% %%   \begin{array}{c}
%% %%   (f{:}\forall\oln{a}{n} @.@ \oln{\tau}{m} -> \tau) \in \Sigma \quad 
%% %%   \etrans{\Sigma}{\ol{a},\ol{x{:}\tau}}{e} = \formula{t}
%% %%   \end{array}
%% %%   -------------------------------------------------------------------{TFDef}
%% %%   \dtrans{\Sigma}{(f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ e)} =  \formula{ (\forall x @.@ f(\oln{x}{m}) = t) }
%% %%   ~~~~~ 
%% %%   \begin{array}{l}
%% %%   (f{:}\forall\oln{a}{n} @.@ \oln{\tau}{m} -> \tau) \in \Sigma \quad 
%% %%   \etrans{\Sigma}{\ol{a},\ol{x{:}\tau}}{e} = \formula{t} \\
%% %%   constrs(\Sigma,T) = \ol{K} \\
%% %%   \text{for each branch}\;(K\;\oln{y}{l} -> e') \\
%% %%   \quad \begin{array}{l}
%% %%            (K{:}\forall \cs @.@ \oln{\sigma}{l} -> T\;\oln{c}{k}) \in \Sigma \\
%% %%            \etrans{\Sigma}{\ol{a},\ol{x{:}\tau},\ol{y{:}\sigma[\taus/\cs]}}{e'} = \formula{ t_K }
%% %%         \end{array}
%% %%   \end{array}
%% %%   -------------------------------------------------------------------{TCaseDef}
%% %%   \begin{array}{l}
%% %%    \dtrans{\Sigma}{(f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'})} = \\
%% %%    \quad \formula{ \begin{array}{lll} \forall \oln{x}{m} @.@ & \hspace{-7pt} (t = \bad /\ f(\ol{x}) = \bad)\; \lor \\ 
%% %%                                                                     & \hspace{-7pt}(f(\ol{x}) = \unr)\;\lor \\ 
%% %%                                                                     & \hspace{-7pt}(\bigvee(t = K(\oln{{\sel{K}{i}}(t)}{i\in 1..l})\;/\ \\
%% %%                                                                     & \hspace{-5pt}\quad f(\ol{x}) = t_K[\oln{\sel{K}{i}(t)}{i\in 1..l}/\ol{y}]))
%% %%                                                  \end{array}
%% %%                         }
%% %% \end{array}
%% %% \endprooftree  \\ \\ 
%% \end{array}\]
%% \caption{Definition elaboration to FOL}\label{fig:typing}
%% \end{figure}


\begin{figure}\small
\[\begin{array}{c} 
\ruleform{\ctrans{\Sigma}{\Gamma}{e \in \Ct} = \formula{\phi}} \\ \\ 
\prooftree
  \begin{array}{c}
   \etrans{\Sigma}{\Gamma}{e} = \formula{t} \quad
   \etrans{\Sigma}{\Gamma,x}{e'} = \formula{t'}
  \end{array}
  ------------------------------------------{CTransBase}
  \begin{array}{l}
   \ctrans{\Sigma}{\Gamma}{e \in \{(x{:}\tau) \mid e' \}} = \\
  %% \Sigma;\Gamma |- e \in \{(x{:}\tau \mid e' \}
  \;\;\formula{(t = \unr) \lor (t'[t/x] = \unr) \lor (t'[t/x] = \True)}
  \end{array}
  ~~~~~ 
  \begin{array}{c}
  \ctrans{\Sigma}{\Gamma,x}{x \in \Ct_1} {=} \formula{\phi_1} \quad
  \ctrans{\Sigma}{\Gamma,x}{e\;x \in \Ct_2} {=} \formula{\phi_2}
  \end{array} 
  ------------------------------------------{CTransArr}
  \begin{array}{l} 
  \ctrans{\Sigma}{\Gamma}{e \in (x{:}\Ct_1) -> \Ct_2} = 
  \formula{\forall x @.@ \neg \phi_1 \lor \phi_2} 
  \end{array}
  ~~~~~
  \begin{array}{c}
  \ctrans{\Sigma}{\Gamma}{e \in \Ct_1} = \formula{ \phi_1} \quad
  \ctrans{\Sigma}{\Gamma}{e \in \Ct_2} = \formula{ \phi_2}
  \end{array}
  ------------------------------------------{CTransConj}
  \ctrans{\Sigma}{\Gamma}{e \in \Ct_1 \& \Ct_2} = \formula{ \phi_1 /\ \phi_2}
  ~~~~~
  \etrans{\Sigma}{\Gamma}{e} =  \formula{t}
  -------------------------------------------{CTransCf}
  \ctrans{\Sigma}{\Gamma}{e \in \CF} = \formula{\lcf{t}}
 \endprooftree 
%% \\ \\ 
%% \ruleform{\Sigma;\Gamma |- e \notin \Ct \elab{ \phi} } \\ \\
%% \prooftree
%%   \begin{array}{c}
%%    \Sigma;\Gamma |- e : \tau \elab{ t}  \quad
%%    \Sigma;\Gamma,(x{:}\tau) |- e' : \Bool \elab{ t'}
%%   \end{array}
%%   ------------------------------------------{CNTransBase}
%%   \begin{array}{l}
%%   \Sigma;\Gamma |- e \notin \{(x{:}\tau) \mid e' \} 
%%   \elab{(t'[t/x] = \bad) \lor (t'[t/x] = \False)}
%%   \end{array}
%%   ~~~~~ 
%%   \Sigma;\cdot |- \Ct_1 : \tau
%%   ------------------------------------------{CNTransArr}
%%   \begin{array}{l} 
%%   \Sigma;\Gamma |- e \notin (x{:}\Ct_1) -> \Ct_2 
%%   \elab{\exists x @.@ (\Sigma;\Gamma,(x{:}\tau) |- x \in \Ct_1) /\ (\Sigma;\Gamma,(x{:}\tau) |- e\;x \notin \Ct_2)}
%%   \end{array}
%%   ~~~~~
%%   \begin{array}{c}
%%   \Sigma;\Gamma |- e \notin \Ct_1 \elab{ \phi_1} \quad
%%   \Sigma;\Gamma |- e \notin \Ct_2 \elab{ \phi_2}
%%   \end{array}
%%   ------------------------------------------{CNTransConj}
%%   \Sigma;\Gamma |- e \notin \Ct_1 \& \Ct_2 \elab{ \phi_1 \lor \phi_2}
%%   ~~~~
%%   \Sigma;\Gamma |- e : \tau \elab{ t}
%%   -------------------------------------------{CNTransCf}
%%   \Sigma;\Gamma |- e \notin \CF \elab{ \lncf{t}}
%%  \endprooftree
\end{array}\]
\caption{Baseline contract elaboration}\label{fig:typing}
\end{figure}


In addition to contract translation we have an axiomatization in Figure~\ref{fig:prelude}.


\begin{figure}\small
\[\begin{array}{c}
\ruleform{\Th{\Sigma}{P}} \\ \\ 
\begin{array}{lll} 
 \textsc{AxDisjA} & \formula{\bad \neq \unr}  \\ 
 \textsc{AxDisjB} & \formula{\forall \oln{x}{n}\oln{y}{m} @.@ K(\ol{x}) \neq J(\ol{y})} \\ 
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ 
                  & \text{ and } (J{:}\forall\as @.@ \oln{\tau}{m} -> S\;\as) \in \Sigma \\
 \textsc{AxDisjC} & \formula{(\forall \oln{x}{n} @.@ K(\ol{x}) \neq \unr \land K(\ol{x}) \neq \bad)} \\ 
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ \\
 \textsc{AxAppA}  & \formula{\forall \oln{x}{n} @.@ f(\ol{x}) = app(f_{ptr},\xs)} \\
                  & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in P \\
 %% \textsc{AxAppB}  & \formula{\forall \oln{x}{n} @.@ K(\ol{x}) = app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots)} \\
 %%                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\
 \textsc{AxAppC}  & \formula{\forall x, app(\bad,x) = \bad \; /\ \; app(\unr,x) = \unr}    \\ \\
 %% Not needed: we can always extend partial constructor applications to fully saturated and use AxAppC and AxDisjC
 %% \textsc{AxPartA} & \formula{\forall \oln{x}{n} @.@ app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots) \neq \unr} \\
 %%                  & \formula{\quad\quad \land\; app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots) \neq \bad} \\
 %%                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{m} -> T\;\as) \in \Sigma \text{ and } m > n \\
 \textsc{AxPartB} & \formula{\forall \oln{x}{n} @.@ app(f_{ptr},\xs) \neq \unr} \\
                  & \formula{\quad\land\; app(f_{ptr},\xs) \neq \bad} \\
                  & \formula{\quad\land\; \forall \oln{y}{k} @.@ app(f_{ptr},\xs) \neq K(\ol{y})} \\
                  & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P  \\
                  & \text{ and every } (K{:}\forall\as @.@ \oln{\tau}{k} -> T\;\as) \in \Sigma \text{ and } m > n  \\ \\ 
 \textsc{AxInj}   & \formula{\forall \oln{y}{n} @.@ \sel{K}{i}(K(\ys)) = y_i} \\ 
                  & \text{for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \text{ and } i \in 1..n \\ \\
\end{array} \\
\ruleform{\Th{\Sigma}{P}^{\lcfZ}} \\ \\ 
\begin{array}{lll} 
 \textsc{AxCfA}   & \formula{\lcf{\unr} /\ \lncf{\bad}} \\
 \textsc{AxCfB}   & \formula{\forall \oln{x}{n} @.@ \lcf{K(\ol{x})} <=> \bigwedge\lcf{\ol{x}}} \\
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma
\end{array}
\end{array}\]
\caption{Prelude theory}\label{fig:prelude}
\end{figure}


For a given program $P$ and expression $e$, we will view the denotational 
semantics $\dbrace{P}^{\infty}$ and $\interp{e}{\dbrace{P}^\infty}{\cdot}$ as first-order 
logic {\em models}. We use the elements of $D_{\infty}$ as the underlying set. We define
an interpretation of functions on the image of translation into FOL as: 
\[\begin{array}{rcl}
   \linterp{f^{\ar}}  & = & \dlambda (d {:} \prod_{\ar}D_{\infty}) @.@ \dapp(\dbrace{P}^{\infty}(f),\oln{\pi_i(d)}{i \in 1..\ar}) \\ 
   \linterp{f_{ptr}}  & = & \dbrace{P}^{\infty}(f) \\ 
   \linterp{app}     & = & \dapp \\ 
   \linterp{K^{\ar}}  & = & \dlambda (d {:} \prod_{\ar}D_{\infty}) @.@ \roll(\ret(\inj{K}(d))) \\ 
   \linterp{\sel{K}{i}} & = & \dlambda (d {:} D_{\infty}) @.@ \roll(\bind_g(\unroll(d))) \\ 
     \text{where } g  & = & [\;\bot \\ 
                      &   & ,\;\dlambda d @.@ \unroll(\pi_i(d))  \quad (\text{case for constructor } K) \\ 
                      &   & ,\;\bot \\ 
                      &   & ,\;\ldots\\ 
                      &   & ,\;\bot\; ]
\end{array}\]

\begin{theorem}
If $\Sigma |- P$ then we have that $\langle D_{\infty},{\cal I}\rangle \models \Th{\Sigma}{P}$. 
\end{theorem} 
\begin{proof} It is straightforward to confirm that every axiom in $\Th{\Sigma}{P}$ is true in the model. \end{proof}


\subsection{Definitions}\label{sect:defs} 

It is straightforward unfolding of definitions to show that:

\begin{theorem}
If $\Sigma |- P$ then $\langle D_{\infty},{\cal I}\rangle \models \dtrans{\Sigma}{P}$. 
\end{theorem}


\subsection{Contract satisfaction and crash-freedom}\label{sect:cf}
\newcommand{\Fcf}{F_{\lcfZ}} 

We would like to define a set of contract-satisfying denotations and also a set of contract-satisfying terms, 
characterized by $P |- e \in \Ct$, such that the following claim becomes true:

\begin{proposition} Assume that $\Sigma |- P$ and $fv(e) \subseteq dom(P)$, i.e. $e$ is closed.
Then: $\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{\Delta}{e \in \Ct}$ iff $P |- e \in \Ct$.
\end{proposition}

Now there are several problems with coming up with a good definition of $P |- e \in \Ct$, 
which we elaborate in the following sections.

\subsubsection{Problem I: Crash-freedom} 

Ideally we would like to define crash-freedom {\em semantically} using the following 
strict bifunctor on admissible sets $S^{-},S^{+} \subseteq D_{\infty}$.
{\setlength{\arraycolsep}{2pt}
\[\begin{array}{rcl}
   F_{\lcfZ}(S^{-},S^{+}) & = & \{\;d\;\mid\;\unroll(d) \neq \ret(\inj{bad}(1))\;\land\; \\ 
                      &    & \quad \forall \ol{d} @.@ \unroll(d){=}\ret(\inj{K_1^\ar}\langle\oln{d}{\ar}\rangle) ==> \ol{d} \in S^{+} \} \\ 
                   & \cup & \ldots \\ 
                   & \cup & \{\;d\;\mid\;\unroll(d) \neq \ret(\inj{bad}(1))\;\land\; \\ 
                   &      & \quad \forall d_0 @.@ \unroll(d) = \ret(\inj{->}(d_0)) ==> \\ 
                   &      & \quad\quad \forall\;d' \in S^{-} ==> \dapp(d,d') \in S^{+} \}  \\
\end{array}\]}
The $\Fcf$ bifunctor has a negative and positive fixpoint, and by minimal invariance they coincide (one direction 
follows by Tarski-Knaster, the other can be inductively proved using the approximations on ever element of $D_{\infty}$ given
in Lemma~\ref{lem:min-inv-reqs} and the fact that the lub of the chain of $\rho_i$ is the identity and the fact that this 
functor preserves admissibility for the positive sets). Let us call this admissible set $\Fcf^{\infty} \subseteq D_{\infty}$.

We consider this predicate to be the ``ideal crash-freedom'' -- however it is very difficult to give a 1-1 operational
definition. The reason is that the $\Fcf$ functor quantifies in the function case over any $d'$ -- whereas in the operational
semantics it is only reasonable that we quantify over all terms (or over terms that do not contain @BAD@) In the absense of 
full abstraction of the domain (which is plausible, especially if we extend the language with other features) it is unclear 
what a corresponding predicate would look like in terms of operational semantics. 

We then go for a simpler predicate, which only characterizes crash-freedom for first-order terms, 
generate by the following functor on {\em admissible} sets of denotations:
{\setlength{\arraycolsep}{2pt}
\[\begin{array}{rcl}
   G_{\lcfZ}(S^{+}) & = & \{\;d\;\mid\; \unroll(d){=}\ret(\inj{K_1^\ar}\langle\oln{d}{\ar}\rangle) \land \ol{d} \in S^{+} \} \\ 
                  & \cup & \ldots \\ 
                  & \cup & \{\;\bot\;\}
\end{array}\]}
Notice that if $S$ is admissible then so is $G_{\lcfZ}(S)$. 

%% The $G_{\lcfZ}$ functor has a fixpoint and it is an admissible relation, and we will use its 
%% fixpoint $G_{\lcfZ}^\infty$, so now we need to say what $G_{\lcfZ|}^\infty$ means operationally. 
\begin{lemma} The functor $G_{\lcfZ}$ has a unique fixpoint $G_{\lcfZ}^\infty$ on admissible sets. \end{lemma}
\begin{proof} 
The intersection of admissible sets is admissible. Hence we have a complete join semi-lattice (which induces a 
complete lattice), so the monotone functor $G_{\lcfZ}$ does have a smallest and a greatest fixpoint call
it $G_{\lcfZ}^{min}$ and $G_{\lcfZ}^{max}$. Moreover this fixpoint will be an admissible relation. Now it must be 
that $G_{\lcfZ}^{min} \subseteq G_{\lcfZ}^{max}$ so we only show next that
also $G_{\lcfZ}^{max} \subseteq G_{\lcfZ}^{min}$. To do this we will show that:
\[ \forall i. d \in G_{\lcfZ}^{max} ==> \rho_i(d) \in G_{\lcfZ}^{min} \] 
by induction on $i$. For $i = 0$ it follows since $\rho_0(d) = \bot$. Let us assume 
that it holds for $i$, we need to show that $\rho_{i+1}(d) \in G_{\lcfZ}(G_{\lcfZ}^{min})$.
We know however that $d \in G_{\lcfZ}(G_{\lcfZ}^{max}$ and by simply case analysis and appealing
to the induction hypothesis we are done. Finally, by admissibility it must be that
$\sqcup\rho_i(d) \in G_{\lcfZ}^{min}$ and by Lemma~\ref{lem:min-inv-reqs} it
must be that $d \in G_{\lcfZ}^{min}$. This means that the two fixpoints coincide, 
hence there is only a unique fixpoint of $G_{\lcfZ}$, call it $G_{\lcfZ}^\infty$.
\end{proof} 

Now, we would like to define operationally the set of {\em crash-free} terms as a set $\Ecf$ of 
closed terms that satisfies:
{\setlength{\arraycolsep}{2pt}
\[\begin{array}{rcl}
   \Ecf & =    & \{ e \;\mid\; P |- e \Downarrow K[\taus](\ol{e}) /\ \ol{e} \in \Ecf \} \\
        & \cup & \ldots \\
        &      & \{ e \;\mid\; P \not|- e \Downarrow \} 
\end{array}\]}%
We do not know that the set $\Ecf$ exists, so we have to prove it. 
\begin{lemma}
There exists a largest set that satisfies the $\Ecf$ equation above.
\end{lemma} 
\begin{proof}
Define $\Ecf$ to be the set
\[ \{ e\;\mid\; \interp{e}{\dbrace{P}^\infty}{\cdot} \in G_{\lcfZ}^{\infty}\} \]
It is straightforward (by computational adequacy) to show that it satisfies the $\Ecf$ recursive
equation above. For uniqueness, assume any other set $E$ that satisfies the recursive equation
above. We can show that $\interp{E}{\dbrace{P}^\infty}{\cdot}$ is a
fixpoint of $G_{\lcfZ}$ and since there is only one such fixpoint, this is unique. So we have that:
\[\begin{array}{ll}
 e \in E & ==> \\ 
 \interp{e}{\dbrace{P}^\infty}{\cdot} \in \interp{E}{\dbrace{P}^\infty}{\cdot} & ==> \\
 \interp{e}{\dbrace{P}^\infty}{\cdot} \in G_{\lcfZ}^\infty & ==> \\
 e \in \Ecf 
\end{array}\] 
\end{proof}
%% \begin{lemma} 
%% If $e \in E$ and $\interp{e}{\dbrace{P}^\infty}{\cdot} = \interp{e'}{\dbrace{P}^\infty}{\cdot}$ then $e' in E$.
%% \end{lemma}
%% This relies on the fact that 
%% if $\interp{e}{\dbrace{P}^\infty}{\cdot} \in \interp{E}{\dbrace{P}^\infty}{\cdot}$ then $e \in E$. Why is 
%% that? Because the assumption means that 
%% $\interp{e}{\dbrace{P}^\infty}{\cdot} \in \{ d | \exists e' \in E /\ d = \interp{e'}{\dbrace{P}^\infty}{\cdot} \}$
%% and hence this means that there exists some $e' \in E $ such that 
%% $\interp{e}{\dbrace{P}^\infty}{\cdot} = \interp{e'}{\dbrace{P}^\infty}{\cdot}$ 
%% \end{proof} 

Let us extend the interpretation function above $\linterp{\cdot}$ so that: 
\[\begin{array}{rcl}
   \linterp{\lcfZ}  & = & G_{\lcfZ}^{\infty} 
\end{array}\]

\begin{theorem}
If $\Sigma |- P$ then we have that $\langle D_{\infty},{\cal I}\rangle \models \Th{\Sigma}{P}^{\lcfZ}$.
\end{theorem}

Notice that the axiom:
\[  \textsc{AxCfC}  \quad \formula{\forall x y @.@ \lcf{x} /\ \lcf{y} => \lcf{app(x,y)}} \]
is {\em not validated} by this interpretation of crash-freedom we have given. 


\subsubsection{Problem II: the absense of full-abstraction}

Unfortunately higher-orderness bites again. Having defined the set $\Ecf$ we might define formally
the predicate $P |- e \in \Ct$ where $fv(e) \subseteq dom(P)$ and $fv(\Ct) \subseteq dom(P)$ as 
follows:
{\setlength{\arraycolsep}{2pt}
\[\begin{array}{lcl}
    P |- e \in \{ x\;\mid\;e_p\} & <=> & P |- e \not\Downarrow \text{ or } P |- e_p[e/x] \not\Downarrow \text{ or} \\ 
                                 &     & P |- e_p[e/x] \Downarrow True \\
    P |- e \in (x{:}\Ct_1) -> \Ct_2 & <=> & 
                                 \text{for all } P' e' \text{ s.t. } fv(e') \subseteq dom(P{\uplus}P')  \\ 
                                   &   &  \text{it is } P\uplus P' |- e\;e' \in \Ct_2[e'/x] \\
    P |- e \in \Ct_1 \& \Ct_2 & <=> & P |- e \in \Ct_1 \text{ and } P |- e \in \Ct_2 \\
    P |- e \in \CF            & <=> & e \in \Ecf 
\end{array}\]}

Note we made the definition above well-scoped but not necessarily well-typed; let's ignore that for now (making everything
well-typed includes extra difficulties in the proof but hopefully not surmountable).

The interesting case is the case for arrow contracts, where we have extended the set of definitions $P$ with more 
definitions $P'$ -- that is to allow for tests $e'$ which can have arbitrary computational power, and not only those
that can be constructed in the current environment. That is expected the way we have set up things, so let us examine
what happens when we try to prove the proposition below:

\begin{proposition} Assume that $\Sigma |- P$ and $fv(e) \subseteq dom(P)$, i.e. $e$ is closed.
Then: $\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{\Delta}{e \in \Ct}$ iff $P |- e \in \Ct$.
\end{proposition}

{\flushleft{\em Failed proof}:}
The base case and the case of $\CF$ follow from computational adequacy so we are good. However
let's try to prove the arrow case and in particular the $(<=)$ direction. 

Let us assume that for all $P'$ and $e'$ such that $fv(e') \subseteq dom(P\uplus P')$ it is the case that
$P |- e\;e' \in \Ct_2[e'/x]$. We need to show that $\langle D_\infty,{\cal I}\rangle$ is a model of the 
formula $\forall x. \ctrans{\Sigma}{x}{x \in \Ct_1} => \ctrans{\Sigma}{x}{e\;x \in \Ct_2}$. Let us fix
a denotation $d \in D_{\infty}$ and let us assume 
that $\langle D_{\infty},{\cal I} \rangle \models \ctrans{\Sigma}{x}{x \in \Ct_1}[d/x]$. However, this does not 
necessarily mean that we can find a closed $e'$ and $P'$, such 
that $\interp{e'}{\dbrace{P{\uplus}P'}^\infty}{\cdot} = d$ to be able to use the assumptions, unless some sort
of full-abstraction property is true. So we are stuck.

Here is a concrete counterexample, based on the lack of full-abstraction due to the {\em parallel or} function. 
Consider the program $P$ below:
\[\begin{array}{lcl}
f_\omega & |-> & f_\omega \\
f & |-> & \lambda (b{:}Bool) @.@ \lambda (h{:}Bool->Bool->Bool) @.@ \\
  &     & \quad @if@\;(h\;True\;b)\;\&\&\;(h\;b\;True)\;\&\& \\ 
  &     & \quad\qquad\qquad not\;(h\;False\;False)\;@then@ \\
  &     & \quad\quad @if@\;(h\;True\;f_\omega)\;\&\&\;(h\;f_\omega\;True)\;@then@\;@BAD@ \\
  &     & \quad\quad @else@\;True \\
  &     & \quad @else@\;True
\end{array}\]
Consider now the candidate contract for $f$ below: 
\[ \CF -> (\CF -> \CF -> \CF) -> \CF \]
Operationally we may assume a crash-free boolean as well as a function $h$ which is 
$\CF -> \CF -> \CF$. The first conditional ensures that the function behaves like an ``or'' function or 
diverges. However if we pass the first conditional, 
the second conditional will always diverge and hence the contract will be satisfied. 

However, denotationally it is possible to have a {\em monotone} function $por$ defined as follows:
\[\begin{array}{lcl}
  por\;\bot\;\bot & = & \bot \\ 
  por\;\bot\;True & = & True \\
  por\;True\;\bot & = & True \\ 
  por\;False\;False & = & False
\end{array}\] 
with the rest of the equations (for @BAD@ arguments) induced by monotonicity and whatever boolean value 
we like when both arguments are @BAD@. 

Now, this is denotationally a $\CF -> \CF -> \CF$ function, and it will pass the first conditional, but it will
also pass the second conditional, yielding @BAD@. Hence denotationally the contract for $f$ {\em does not hold}.

So we have a concrete case where the $<=$ direction fails. Because of contra-variance of arrow contracts, it is 
likely that the $=>$ direction is false as well. 


%% Now it may be the case that for all denotations that semantically satisfy a contract, these denotations {\em are} 
%% realizable by a term $e'$ and a context $P'$ but it is not entirely clear how to prove this (or if this is a good
%% idea). I am not sure if this is true either.
%% The other idea out of this situation is to compile the arrow contract differently by not quantifying over all 
%% denotations but rather some kind of {\em definable} denotations -- but I do not know how exactly to do this.


\paragraph{A way out of this?}
Well, if we restrict our higher-order tests to those that can be constructed from our signature then 
we may define the following:

{\setlength{\arraycolsep}{2pt}
\[\begin{array}{lcl}
    P |- e \in \{ x\;\mid\;e_p\} & <=> & P |- e \not\Downarrow \text{ or } P |- e_p[e/x] \not\Downarrow \text{ or} \\ 
                                 &     & P |- e_p[e/x] \Downarrow True \\
    P |- e \in (x{:}\Ct_1) -> \Ct_2 & <=> & 
                                 \text{for all } e' \text{ s.t. } fv(e') \subseteq dom(P)  \\ 
                                   &   &  \text{it is } P |- e\;e' \in \Ct_2[e'/x] \\
    P |- e \in \Ct_1 \& \Ct_2 & <=> & P |- e \in \Ct_1 \text{ and } P |- e \in \Ct_2 \\
    P |- e \in \CF            & <=> & e \in \Ecf 
\end{array}\]}
Notice that the difference with the previous version of $P |- e \in \Ct$ is that we {\em do not} extend the 
definitions $P'$ so we don't get the full power of higher-order tests. We show that {\em in the current signature
only} does the program satisfy the contract. 

\newcommand{\definable}[1]{{\mathop{def}}(#1)}

Why did we do this change? Because denotationally this is not terribly hard to support -- instead of translating 
\[\begin{array}{l}
  \ctrans{\Sigma}{\Gamma}{e \in (x{:}\Ct_1) -> \Ct_2} =  
  \formula{\forall x @.@ \ctrans{\Sigma}{\Gamma,x}{x \in \Ct_1} => \ctrans{\Sigma}{\Gamma,x}{e\;x \in \Ct_2}}
\end{array}\] 
we use the following:
\[\begin{array}{l}
  \ctrans{\Sigma}{\Gamma}{e \in (x{:}\Ct_1) -> \Ct_2} = \\ 
  \qquad\qquad\quad 
\formula{\forall x @.@ \definable{x} \land \ctrans{\Sigma}{\Gamma,x}{x \in \Ct_1} => \ctrans{\Sigma}{\Gamma,x}{e\;x \in \Ct_2}}
\end{array}\] 
where $\definable{x}$ could be axiomatized as containing all terms 
made up of the functions in $P$, applications, and data constructors:

\[\begin{array}{lll} 
 \textsc{DefCons} & \formula{\forall \xs @.@ \definable{K(\xs)} <=> \definable{\xs}} \\
                        & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\
 \textsc{DefFun}  & \formula{\definable{f_{ptr}}}  \\
                        & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in P \\
 \textsc{DefApp}  & \formula{\forall x y @.@ \definable{x}\land\definable{y} => \definable{app(x,y)}}
%% \formula{\bad \neq \unr}  \\ 
%%  \textsc{AxDisjB} & \formula{\forall \oln{x}{n}\oln{y}{m} @.@ K(\ol{x}) \neq J(\ol{y})} \\ 
%%                   & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ 
%%                   & \text{ and } (J{:}\forall\as @.@ \oln{\tau}{m} -> S\;\as) \in \Sigma \\
%%  \textsc{AxDisjC} & \formula{(\forall \oln{x}{n} @.@ K(\ol{x}) \neq \unr \land K(\ol{x}) \neq \bad)} \\ 
%%                   & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ \\
%%  \textsc{AxAppA}  & \formula{\forall \oln{x}{n} @.@ f(\ol{x}) = app(f_{ptr},\xs)} \\
%%                   & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in P \\
%%  %% \textsc{AxAppB}  & \formula{\forall \oln{x}{n} @.@ K(\ol{x}) = app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots)} \\
%%  %%                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\
%%  \textsc{AxAppC}  & \formula{\forall x, app(\bad,x) = \bad \; /\ \; app(\unr,x) = \unr}    \\ \\
%%  %% Not needed: we can always extend partial constructor applications to fully saturated and use AxAppC and AxDisjC
%%  %% \textsc{AxPartA} & \formula{\forall \oln{x}{n} @.@ app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots) \neq \unr} \\
%%  %%                  & \formula{\quad\quad \land\; app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots) \neq \bad} \\
%%  %%                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{m} -> T\;\as) \in \Sigma \text{ and } m > n \\
%%  \textsc{AxPartB} & \formula{\forall \oln{x}{n} @.@ app(f_{ptr},\xs) \neq \unr} \\
%%                   & \formula{\quad\land\; app(f_{ptr},\xs) \neq \bad} \\
%%                   & \formula{\quad\land\; \forall \oln{y}{k} @.@ app(f_{ptr},\xs) \neq K(\ol{y})} \\
%%                   & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P  \\
%%                   & \text{ and every } (K{:}\forall\as @.@ \oln{\tau}{k} -> T\;\as) \in \Sigma \text{ and } m > n  \\ \\ 
%%  \textsc{AxInj}   & \formula{\forall \oln{y}{n} @.@ \sel{K}{i}(K(\ys)) = y_i} \\ 
%%                   & \text{for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \text{ and } i \in 1..n \\ \\
%% \end{array} \\
%% \ruleform{\Th{\Sigma}{P}^{\lcfZ}} \\ \\ 
%% \begin{array}{lll} 
%%  \textsc{AxCfA}   & \formula{\lcf{\unr} /\ \lncf{\bad}} \\
%%  \textsc{AxCfB}   & \formula{\forall \oln{x}{n} @.@ \lcf{K(\ol{x})} <=> \bigwedge\lcf{\ol{x}}} \\
%%                   & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma
\end{array}\]


In the model, $\definable{\cdot}$ should be possible to define, as a
predicate on denotations. The disadvantage to this approach is that
arrow contracts will only hold for whatever is in your context, not
arbitrary expressions, which might be what we want, but might not be
modular enough.

The other {\em potential} problem (i.e. I have not yet checked) might be in the 
proof of admissibility of induction. 

And yet another potential problem is that as we incrementally extend our signature 
with new function definitions (and possibly contracts) previously defined contracts
may no longer hold. This is pretty bad for modularity.

\paragraph{Yet another possible solution}

A solution that seems somewhat more modular is based on the observation that, 
during the evaluation of a program there exists a {\em set} of terms (maybe infinite) that can
appear as arguments to other terms or functions. Our idea is to guard the arrow contracts so that
we do not quantify over any possible term (or denotation, in the translation) but rather only 
those that may appear as {\em arguments} in some application. We translate arrow contract as 
follows:
\[\begin{array}{l}
  \ctrans{\Sigma}{\Gamma}{e \in (x{:}\Ct_1) -> \Ct_2} = \\ 
  \qquad\qquad\quad 
\formula{\forall x @.@ arg(x) \land \ctrans{\Sigma}{\Gamma,x}{x \in \Ct_1} => \ctrans{\Sigma}{\Gamma,x}{e\;x \in \Ct_2}}
\end{array}\] 
where $arg(x)$ ensures that $x$ is the denotation of a term that will be passed as an argument to $e$. We'd need to define
a similar predicate on the evaluation relation, call it $Arg(e)$ and modify the program translation to thread the $arg(\cdot)$
predicate through. 


\subsection{Contract satisfaction for base contracts}\label{sect:cf}

In this section we will attempt to ignore the higher-order case and just talk about 
base contracts. Let us use:

The following are true: 
\begin{lemma}[Base contract adequacy]\label{lem:base-contract-adequacy}
Assume that $\Sigma |- P$ and $fv(e) \subseteq dom(P)$, i.e. $e$ is closed.
If $\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{\Delta}{e \in \CF}$ then $P |- e \in \CF$. If $\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{\Delta}{e \in \{ x \mid e' \}}$ then $P |- e \in \{x \mid e' \}$.
\end{lemma}
{\bf DV: Generalize this to a notion of base contracts that includes conjuctions.}

In fact the above two statements hold if we extend the interpretation 
of crash-freedom in the model to contain elements from the function 
space as well. 

Because of the full-abstraction problems we have observed above it 
is not possible to state similar statements for arrow contracts. 


\subsection{Invocation of a theorem prover}\label{sect:infocation}

Given a program $P$ with signature $\Sigma$, that is $\Sigma |- P$, we may define the theory
${\cal T}$ as follows:
     \[ \Th{\Sigma}{P}\;\land\;\Th{\Sigma}{P}^{\lcfZ}\;\land\;\dtrans{\Sigma}{P} \]
we know that $\langle D_\infty,{\cal I}\rangle \models {\cal T}$ from the previous sections. 
Assume below that $f$ is a function such that $f \in dom(P)$ and $fv(\Ct) \subseteq dom(P)$.

\begin{theorem}[Soundness]\label{thm:prover-soundess}
If ${\cal T}\;\land\;\neg(\ctrans{\Sigma}{P}{f \in \Ct})$ is 
unsatisfiable then $\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{P}{f \in \Ct}$.
\end{theorem}
\begin{proof}
If there is no model for this formula (i.e. the theorem prover returns ``unsatisfiable'') then
its negation must be valid (true in all models), that 
is ${\cal T} -> \ctrans{\Sigma}{P}{f \in \Ct}$ is valid. By completeness
of first-order logic ${\cal T} |- \ctrans{\Sigma}{P}{f \in \Ct}$. This means in 
turn that all models of ${\cal T}$ validate $\ctrans{\Sigma}{P}{f \in \Ct}$. In particular 
for the denotational model we have that $\langle D_\infty,{\cal I}\rangle \models {\cal T}$ 
and hence $\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{P}{f \in \Ct}$.
\end{proof}

\subsubsection{End-goal and incremental verification}\label{sect:incremental}

Assume that we are given a program $P$ with a function $f \in dom(P)$, for which we have 
already showed that $\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{P}{f \in \Ct_f}$. 
Suppose next that we are presented with a ``next'' goal, to prove that 
$\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{P}{h \in \Ct}$. 
We may consider the following three variations of how to do this:

\begin{itemize}
  \item Simply ask for the unsatisfiability of: 
    \[  \Th{\Sigma}{P}\;\land\;
        \Th{\Sigma}{P}^{\lcfZ}\;\land\;\dtrans{\Sigma}{P}\;\land\;\neg\ctrans{\Sigma}{P}{h \in \Ct_h} \] 
        The soundness of this query follows directly from Theorem~\ref{thm:prover-soundess} above.

  \item Ask for the unsatisfiability of:
    \[  \Th{\Sigma}{P}\;\land\;
        \Th{\Sigma}{P}^{\lcfZ}\;\land\;\dtrans{\Sigma}{P}\;\land\;\ctrans{\Sigma}{P}{f \in \Ct_f}\;\land\;\neg\ctrans{\Sigma}{P}{h \in \Ct_h}     \] 
        This query adds the {\em already proven} contract for $f$ in the theory. If this formula
        is unsatisfiable, then its negation is valid, and we know that the denotational model is 
        a model of the theory {\em and} of $\ctrans{\Sigma}{P}{f \in \Ct_f}$ and hence it must also
        be a model of $\ctrans{\Sigma}{P}{h \in \Ct_h}$. 
  \item Ask for the unsatisfiability of:
    \[  \Th{\Sigma}{P}\;\land\;
        \Th{\Sigma}{P}^{\lcfZ}\;\land\;\dtrans{\Sigma}{P \setminus f}\;\land\;\ctrans{\Sigma}{P}{f \in \Ct_f}\;\land\;
        \neg\ctrans{\Sigma}{P}{h \in \Ct_h}     \] 
        This query removes the axioms associated with the definition of $f$ since we may only have 
        its signature and contract available. Via a similar reasoning as before, such an invocation 
        is sound.
\end{itemize}

Our final goal is going to show that a program does not crash, that
is the final contract will be of the form $e \in \Ct$ where $\Ct$ is
going to be some {\em base contract}. Note that by base contract adequacy
(Lemma~\ref{lem:base-contract-adequacy}) if we manage to show a base contract 
denotationally, then the contract holds in operational terms.

To the extend that in the end we are only interested in base contracts, giving a 
denotational semantics of full-higher-order contracts is not really interesting 
but we do this anyway. For a given denotation $d$, we define the 
predicate $\interp{\Ct}{\dbrace{P}^\infty}{\rho}(d)$ by recursion on the structure 
of the contract $\Ct$, such that:

\[\begin{array}{l}
    \interp{\{x \mid e\}}{\dbrace{P}^\infty}{\rho}(d) \text{ iff } \\
        \quad \unroll(d) = \bot \text{ or } 
        \unroll(\interp{e}{\dbrace{P}^\infty}{\rho,x|->d}) = \bot\;\text{ or } \\
        \quad \unroll(\interp{e}{\dbrace{P}^\infty}{\rho,x|->d}) = \ret(\inj{\mathop{True}}(1)) \\ \\
    \interp{\dbrace{(x{:}\Ct_1) -> \Ct_2}{P}^\infty}{\rho}(d) \text{ iff } \\
        \quad \text{for all } d_x \in D_\infty \\ 
        \quad\quad \text{if }
                     \interp{\Ct_1}{\dbrace{P}^\infty}{\rho}(d_x)\text{ then }
                     \interp{\Ct_2}{\dbrace{P}^\infty}{\rho,x|->d_x}(\dapp(d,d_x)) \\ \\ 
    \interp{\CF}{\dbrace{P}^\infty}{\rho}(d) \text{ iff }  d \in \Fcf^{\infty} \\  \\ 
    \interp{\Ct_1 \& \Ct_2}{\dbrace{P}^\infty}{\rho}(d) \text{ iff } 
       \interp{\Ct_1}{\dbrace{P}^\infty}{\rho}(d) \text{ and } 
       \interp{\Ct_2}{\dbrace{P}^\infty}{\rho}(d)
\end{array}\]

Then we have the rather obvious theorem below.

\begin{theorem}[Soundness and completeness for denotational semantics]
Assume a program $P$ with signature $\Sigma$, and expression $e$ and contract $\Ct$ 
such that $fv(e) \cup fv(\Ct) \subseteq dom(P)$. Then 
$\langle D_\infty,{\cal I}\rangle \models \ctrans{\Sigma}{P}{e \in \Ct}$ iff
$\interp{\Ct}{\dbrace{P}^{\infty}}{\cdot}(\interp{e}{\dbrace{P}^\infty}{\cdot})$.
\end{theorem}


{\bf DV: So basically this is Simon's strategy of side-stepping the lack of full abstraction
and the associated problems with it: In the end of the day we only care about base contracts,
in fact really only about the contract ``is this program crash-free'', so we don't have to make
a big fuss about higher-order contracts and their operational semantics. We have to motivate it
carefully and also be clear that for the intellectually curious reader who really wants to know what statement we have proved for a function contract when the prover says ``unsat'' we might want to give a full definition of the denotational meaning of contracts including both base and higher-order. I think we do not have the time luxury to look for more elaborate solutions (such as definable denotations and all that crazy stuff) to match the operational and the denotational semantics for higher-order contracts. Fullstop.}



\section{Counterexamples and minimization}

For a query of the form ${\cal T}\;\land\;\neg(\ctrans{\Sigma}{P}{e \in \Ct})$, a satisfiability checker will search for
a model. When such a model exists, it will include tables for the function symbols in the formula. Notice that functions 
in FOL are total over the domain of the terms in the model. This means that function tables may be {\em infinite} if the 
terms in the model are infinite. Several (very useful!) axioms such as the discrimination axioms \textsc{AxDisjB} may in 
fact force the domains of functions operating e.g. on lists to be infinite. For instance consider the following devinitions:
\begin{code}
length [] = Z
length (x:xs) = S (length xs)

isZero Z = True
isZero _ = False
\end{code}
Suppose that we would like to check that 
   \[ @length@ \in \CF -> \{ x \mid @isZero@\;x\} \]
which is a falsifiable contract.  A satisfiability-based checker (such as \textsc{Eprover})
will simply diverge trying to construct a counter model for the negation of the above query.
Indeed the table for @length@ is infinite since @[]@ is always disjoint from @Cons x x@ for 
any @x@ and @xs@.

From a practical point of view this is not acceptable: After all, there exists a very simple 
counterexample that demonstrates the problem, namely @Cons Z []@, and we only need the 
functions of our program to be defined on a {\em finite} number of values (those that appear 
during the evaluation of this problematic counterexample) to be able to demonstrate 
the problem. We simply {\em do not care} about values that a function may take outside the set 
of expressions that appear during the finite evaluation of a counterexample.

Hence we need a way to minimize the set of terms to only the {\em interesting ones} for 
the evaluation of a counterexample. In FOL we introduce the predicate $min(\cdot)$ to serve
this goal. We update our Prelude theory axioms as follows:
\[\setlength{\arraycolsep}{2pt}
\begin{array}{c}
%% \ruleform{\Th{\Sigma}{P}} \\ \\ 
\begin{array}{lll} 
 \textsc{AxDisjA} & \formula{\bad \neq \unr}  \\ 
 \textsc{AxDisjB} & \formula{\forall \oln{x}{n}\oln{y}{m} @.@} \\ 
                  & \formula{\quad\highlight{min(K(\ol{x})){\land}min(J(\ol{y}))} =>
                                  K(\ol{x}){\neq}J(\ol{y})} \\
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ 
                  & \text{ and } (J{:}\forall\as @.@ \oln{\tau}{m} -> S\;\as) \in \Sigma \\
 \textsc{AxDisjCUnr} & \formula{\forall \oln{x}{n} @.@ \highlight{\neg min(\unr)}} \\ 
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ \\
 \textsc{AxDisjCBad} & \formula{\forall \oln{x}{n} @.@ K(\ol{x}) \neq \bad} \\ 
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ \\

 \textsc{AxAppA}  & \formula{\forall \oln{x}{n} @.@ f(\ol{x}) = app(f_{ptr},\xs)} \\
                  & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in P \\
 %% \textsc{AxAppB}  & \formula{\forall \oln{x}{n} @.@ K(\ol{x}) = app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots)} \\
 %%                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\
 \textsc{AxAppC}  & \formula{\forall x, app(\bad,x) = \bad \; /\ \; app(\unr,x) = \unr}    \\ \\
 %% Not needed: we can always extend partial constructor applications to fully saturated and use AxAppC and AxDisjC
 %% \textsc{AxPartA} & \formula{\forall \oln{x}{n} @.@ app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots) \neq \unr} \\
 %%                  & \formula{\quad\quad \land\; app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots) \neq \bad} \\
 %%                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{m} -> T\;\as) \in \Sigma \text{ and } m > n \\
 %% \textsc{AxPartB} & \formula{\forall \oln{x}{n} @.@ app(f_{ptr},\xs) \neq \unr} \\
 %%                  & \formula{\quad\land\; app(f_{ptr},\xs) \neq \bad} \\
 %%                  & \formula{\quad\land\; \forall \oln{y}{k} @.@ app(f_{ptr},\xs) \neq K(\ol{y})} \\
 %%                  & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P  \\
 %%                  & \text{ and every } (K{:}\forall\as @.@ \oln{\tau}{k} -> T\;\as) \in \Sigma \text{ and } m > n  \\ \\ 
 \textsc{AxInj}   & \formula{\forall \oln{y}{n} @.@ \highlight{min(K(\ys))\;\land\;min(y_i)}} \\ 
                  & \formula{\qquad\qquad => \sel{K}{i}(K(\ys)) = y_i} \\ 
                  & \text{for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \text{ and } i \in 1..n \\ \\
\end{array}
\end{array}\]

In other words, we ensure that constructor applications are disjoint
only for values we are interested in. We will explain each axiom separately later. 
Intuitively we wish to equate all terms that we are not interested in to $\unr$. We 
can never be interested in $\unr$ in the intended model because that means that during
the evaluation of a term, which completed, we encountered a divergent term -- clearly a 
contradiction!

What about function definitions? Figure~\ref{fig:etrans} has to be modified 
slightly as well:

\begin{figure}\small
\[\begin{array}{c}
\ruleform{\utrans{\Sigma}{\Gamma}{t \sim u} = \formula{\phi}} \\ \\ 
\prooftree
   \begin{array}{c} \ \\ \ \\ 
   \etrans{\Sigma}{\Gamma}{e} = \formula{t}
   \end{array}
   ----------------------------------------{TUTm}
   \begin{array}{l} 
   \utrans{\Sigma}{\Gamma}{s \sim e } = \formula{(\highlight{min(s)} => s = t) \lor \highlight{s = \unr}} 
      \ \\ \ \\ \ \\ \ \\
   \end{array}
   ~~~~~
  \begin{array}{l}
  \etrans{\Sigma}{\Gamma}{e} = \formula{t} \quad
  constrs(\Sigma,T) = \ol{K} \\
  \text{for each branch}\;(K\;\oln{y}{l} -> e') \\
  \begin{array}{l}
           (K{:}\forall \cs @.@ \oln{\sigma}{l} -> T\;\oln{c}{k}) \in \Sigma \text{ and }
           \etrans{\Sigma}{\Gamma,\ol{y}}{e'} = \formula{ t_K }
  \end{array}
  \end{array}
  ------------------------------------------{TUCase}
  {       \setlength{\arraycolsep}{2pt} 
  \begin{array}{l}
  \utrans{\Sigma}{\Gamma}{s \sim @case@\;e\;@of@\;\ol{K\;\ol{y}{->}e'}} = \\
  \;\;\formula{
       \begin{array}{l} (\highlight{s{=}\unr})\;\lor \\ 
                            \;\; (\highlight{min(s) => min(t)}\;\land  \\
                            \quad((t = \bad /\ s = \bad)\;\lor \\
                            \quad\quad \bigvee(t = K(\oln{{\sel{K}{i}}(t)}{}) \land
                                           s = t_K[\oln{\sel{K}{i}(t)}{}/\ol{y}])))
                   \end{array}
           }
  \end{array}}
\endprooftree
\end{array}\]
\end{figure}

%% \\ \\ 
%% \ruleform{ \Dtrans{\Sigma}{P} = \formula{\phi}} \\ \\ 
%% \prooftree
%%      \begin{array}{l}       
%%        \text{for each} (f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P \\ 
%%           \quad \utrans{\Sigma}{\ol{x}}{f(\ol{x}) \sim u} = \formula{\phi}
%%      \end{array}
%%      --------------------{TDefs}
%%      \Dtrans{\Sigma}{P} = \bigwedge_{P} \formula{\forall \ol{x} @.@ \phi}
%% \endprooftree 

\newcommand{\curly}{\rightsquigarrow}
Now operationally we may instrument the evaluation relation to keep track of the set of 
closed terms that appear during evaluation. The instrumented relation appears in 
Figure~\ref{fig:opsem-instrumented}. Observe that if $P |- e \Downarrow w \curly S$ then 
$S$ is a {\em finite set} of terms.


\begin{figure}\small
\[\begin{array}{c} 
\ruleform{P |- e \Downarrow v \curly S} \\ \\ 
\prooftree
\begin{array}{c} \ \\ 
\end{array}
-------------------------------------{EVal}
P |- v \Downarrow v \curly \{ v \} 
~~~~
\begin{array}{c}
(f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P \\
P |- u[\ol{\tau}/\ol{a}][\ol{e}/\ol{x}] \Downarrow v \curly S
\end{array}
-------------------------------------{EFun}
P |- f[\ol{\tau}]\;\oln{e}{m} \Downarrow \{ v \} \cup S
~~~~~
\begin{array}{c}  
P |- e_1 \Downarrow v_1 \curly S_1 \quad
P |- v_1\;e_2 \Downarrow w \curly S_2
\end{array}
------------------------------------------------{EApp}
P |- e_1\;e_2 \Downarrow w \curly S_1 \cup S_2 \cup \{ e_1\;e_2 \}
~~~~~
\begin{array}{c}  
P |- e_1 \Downarrow @BAD@ \curly S 
\end{array}
------------------------------------------------{EBadApp}
P |- e_1\;e_2 \Downarrow @BAD@ \curly S \cup \{ e_1\;e_2 \} 
\endprooftree \\ \\ 
\ruleform{P |- u \Downarrow v \curly S} \\ \\
\prooftree
P |- e \Downarrow v \curly S 
-------------------------------------{EUTm}
P |- e \Downarrow v \curly S 
~~~~~
\begin{array}{c}
P |- e \Downarrow K_i[\ol{\sigma}_i](\ol{e}_i) \curly S_1 \quad
P |- e'_i[\ol{e}_i/\ol{y}_i] \Downarrow w \curly S_2 
\end{array}
------------------------------------{ECase}
P |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'} \Downarrow w \curly S_1 \cup S_2
~~~~~
\begin{array}{c}
P |- e \Downarrow @BAD@ \curly S \\
\end{array}
------------------------------------{EBadCase}
P |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'} \Downarrow @BAD@ \curly S
%% \begin{array}{c}
%% (f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{m} @.@ @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}) \in D \\
%% D |- e[\ol{\tau}/\ol{a}][\ol{e}/\ol{x}] \Downarrow @BAD@ \\
%% \end{array}
%% -------------------------------------{EBadCase}
%% D |- f[\ol{\tau}]\;\oln{e}{m} \Downarrow @BAD@
\endprooftree
\end{array}\]
\caption{Redex-instrumented operational semantics}\label{fig:opsem-instrumented}
\end{figure}

\subsection{The intended min-imal model}

Our goal is then going to be to establish the following result, stated in non-technical terms:
\begin{quote}
If there exists a counterexample to a contract, then the negation of the contract-translation
formula is satisfiable not only on $\langle D_\infty,{\cal I}\rangle$ but it also has a {\em finite} 
model. That finite model is a model of our $min$-enabled theory. 
\end{quote}

We start unfolding the story.
For a given program $P$ in a signature $\Sigma$ we have already shown how to construct $D_\infty$ and how
to give interpretations ${\cal I}$ to a first-order vocabulary. Let us assume that the 
program and signature contains a polymorpic $loop$ function, 
for convenience $undefined |-> udefined$. This is a realistic assumption to make (e.g.
comes in the standard Haskell prelude). 

Assume now that we are given a formula $\phi$ defined as: 
\[  \phi = \ctrans{\Sigma}{\cdot}{e \in \Ct_1 -> \ldots \Ct_n -> @B@} \] 
for @B@ a base contract. Assume moreover that there exist $\oln{e}{n}$ closed for the
program $P$ such that for each $e_i$ it is true that:
\[\interp{\Ct_i}{\dbrace{P}^\infty}{\cdot}(\interp{e_i}{\dbrace{P}^\infty}{\cdot})\]. 
Assume however that it is {\em not} the case that 
\[\interp{{\tt B}}{\dbrace{P}^\infty}{\cdot}(\interp{e\;\oln{e}{n}}{\dbrace{P}^\infty}{\cdot})\]
There are two cases for the base constract @B@:
\begin{itemize}
  \item Let us now consider the case where @B@ = $\{ x \mid e_p \}$. By adequacy it must
  be that: $P |- e\;\ol{e} \Downarrow w \curly S_1$ for some $w$ and set $S_1$ and moreover
  $P |- e_p[e\;ol{e}/x] \Downarrow \{ @BAD@, False \} \curly S_2$ for some set $S_2$. 

  Of course the following lemma is true:
  \begin{lemma}\label{lem:curly} 
    If $P |- e \Downarrow w \curly S$ then $S$ is a finite set. Moreover, 
    for every $e' \in S$ there exists $w$ such that $P |- e' \Downarrow w$.
  \end{lemma}
  Moreover we have:
  \begin{lemma}\label{lem:bot-not-redex} 
     If $P |- e \Downarrow w \curly S$ then 
     $\bot \notin \interp{S}{\dbrace{P}^{\infty}}{\cdot}$. 
  \end{lemma}
  \begin{proof} If $\bot \in \interp{S}{\dbrace{P}^{\infty}}{\cdot}$ then there exists
  a term $e \in S$ such that $\interp{e}{\dbrace{P}^{\infty}}{\cdot} = \bot$. This means
  that $P |- e \not\Downarrow$ but that is a contradiction to $e \in S$ by 
  Lemma~\ref{lem:curly}.
  \end{proof}

  Let us now define the minimal sets operationally and denotationally: 
\newcommand{\Min}{\cal M}
  \[\begin{array}{lcl}
           M        & \triangleq & S_1 \cup S_2 \\
           {\cal M} & \triangleq & \interp{S_1\cup S_2}{\dbrace{P}^{\infty}}{\cdot}
  \end{array}\]
  Consider now the function $\mu : D_\infty -> D_\infty$ defined as: 
  \[\begin{array}{lcl} 
        \mu(d) & \triangleq & \left\{ \begin{array}{ll} 
                   d           & \text{when } \unroll(d) = \ret(\inj{bad}(1)) \\
                   d           & \text{when } d \in \Min \\ 
                   \bot        & \text{otherwise } 
                                      \end{array}\right.
  \end{array}\] 
  In other words $\mu(\cdot)$ conflates all the non-interested values to $\bot$. 
  Now we may consider the {\em set} which is the image of $D_\infty$ through $\mu$: 
  \[ D_\infty^\mu  \triangleq \mu(D_\infty) \] 

  Notice that this set is {\em finite} with cardinality at most $card(M) + 2$. Also, 
  we treat this is a {\em set}. Although $D_\infty$ has a domain structure, we do not 
  care about $D_\infty^\mu$ being a domain. 

  Now, in this $D_\infty^\mu$ we may redefine the interpretation of first-order constants
  and variable symbols in our theories, using ${\cal I}^\mu$ below:

%%    \newcommand{\mlinterp}[1]{{\cal I}^\mu(#1)}

%%   \[\begin{array}{rcl}
%%    \mlinterp{f^{\ar}}  & = & \dlambda (d {:} \prod_{\ar}D_{\infty}^\mu) @.@ 
%%                       &   &   if there exist $\oln{e}{\ar}$ such that $f[\taus]\;ol{e} \in M$ and 
%%                       &   &                  \interp{e}{\dbrace{P}^\infty}{\cdot} = d_i then 
%%                       &   &         \mu(\dapp(\dbrace{P}^{\infty}(f),\oln{\pi_i(d)}{i \in 1..\ar})) \\ 
%%    \mlinterp{f_{ptr}}  & = & \dbrace{P}^{\infty}(f) \\ 
%%    \mlinterp{app}     & = & \dapp \\ 
%%    \mlinterp{K^{\ar}}  & = & \dlambda (d {:} \prod_{\ar}D_{\infty}) @.@ \roll(\ret(\inj{K}(d))) \\ 
%%    \mlinterp{\sel{K}{i}} & = & \dlambda (d {:} D_{\infty}) @.@ \roll(\bind_g(\unroll(d))) \\ 
%%      \text{where } g  & = & [\;\bot \\ 
%%                       &   & ,\;\dlambda d @.@ \unroll(\pi_i(d))  \quad (\text{case for constructor } K) \\ 
%%                       &   & ,\;\bot \\ 
%%                       &   & ,\;\ldots\\ 
%%                       &   & ,\;\bot\; ]
%% \end{array}\]

  
  
  




  \item The other case is when $@B@ = \CF$. {\bf TODO}
\end{itemize}







%% \newpage

%% \section{Contract checking soundness} 

%% \section{Contracts}

%% The syntax that we use for contracts is in Figure~\ref{fig:contract-syntax}. 
%% Contracts are typed (here, just monomorphically), and we give an operational 
%% semantics for contract satisfaction in the same figure. 

%% \begin{figure*}\small
%% \[\begin{array}{c} 
%% \ruleform{\Sigma;\Gamma |- \Ct } \\ \\ 
%% \prooftree
%% \Sigma;\Delta,x{:}\tau |- e : \Bool
%% ---------------------------------------{TCBase}
%% \Sigma;\Delta |- \{ (x{:}\tau) \mid e \} : \tau
%% ~~~~ 
%% \begin{array}{c}
%% \Sigma;\Delta |- \Ct_1 : \tau \\
%% \Sigma;\Delta,(x{:}\tau) |- \Ct_2 : \tau' 
%% \end{array}
%% ---------------------------------------{TCArr}
%% \Sigma;\Delta |- (x{:}\Ct_1) -> \Ct_2 : \tau -> \tau'
%% ~~~~ 
%% \Sigma;\Delta |- \Ct_1 : \tau \quad \Sigma;\Delta |- \Ct_2 : \tau 
%% ---------------------------------------{TCConj}
%% \Sigma;\Delta |- \Ct_1 \& \Ct_2 : \tau
%% ~~~~ 
%% \phantom{\Gamma}
%% ---------------------------------------{TCf}
%% \Sigma;\Delta |- \CF : \tau
%% \endprooftree \\ \\ 
%% \ruleform{\Sigma;P |- e \in \Ct} \\ \\
%% \prooftree
%%  P \not|- e \Downarrow 
%% -----------------------------------------------{ECDiv}
%%  \Sigma;P |- e \in \{ (x{:}\tau) \mid e' \}
%%  ~~~~
%%  P |- e'[e/x] \Downarrow \True 
%% -------------------------------------------{ECTrue}
%%  \Sigma;P |- e \in \{ (x{:}\tau) \mid e' \}
%%  ~~~~
%%  P \not|- e'[e/x] \Downarrow 
%%  ------------------------------------------{ECCDiv}
%%  \Sigma;P |- e \in \{ (x{:}\tau) \mid e' \} 
%%  ~~~~~
%%  \begin{array}{c} 
%%  \Sigma;\cdot |- \Ct_1 : \tau \\
%%  \text{for all } u, \Sigma;\cdot |- u : \tau ==> \Sigma;P |- e\;u \in \Ct_2[u/x]
%%  \end{array}
%%  --------------------------------------------{ECArr}
%%  \Sigma;P |- e \in (x{:}\Ct_1) -> \Ct_2 
%%  ~~~~
%%  \begin{array}{c}
%%  \Sigma,\cdot |- e : \tau  \\ 
%%  e \in \Ecf \quad \text{(See Section~\ref{sect:cf})}
%%  %% \text{for all } u, (\Sigma;\cdot |- u : \tau -> \Bool) /\ (@BAD@ \notin u) ==> \neg (P |- u\;e \Downarrow @BAD@)
%%  \end{array}
%%  --------------------------------------------------------------------------------------------{ECf}
%%  \Sigma;P |- e \in \CF 
%%  ~~~~~ 
%%  \Sigma;P |- e \in \Ct_1 \quad \Sigma;P |- e \in \Ct_2
%%  --------------------------------------------------------------------------------------------{ECConj}
%%  \Sigma;P |- e \in \Ct_1 \& \Ct_2
%% \endprooftree
%% \end{array}\]
%% \caption{Contract syntax and semantics}\label{fig:contract-syntax}
%% \end{figure*}







%% \section{Induction and admissibility}
%% {\bf TODO} 


%% \section{Minimization}
%% {\bf TODO} 

%% \section{Some ideas}
%% Sometimes the $\CF$ contract stands in our way e.g. for library stuff. It might 
%% be interesting to explore some user-defined pragma to side-step the $\bad$ case
%% in some pattern matches (i.e. make it on demand, pretty much as $F^{\star}$ does, where
%% only the user's assertions matter.
%% %% \acks
%% %% Acknowledgements here

\end{document}
